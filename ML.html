<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.4"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/index.umd.min.js"></script><script>(e=>{window.WebFontConfig={custom:{families:["KaTeX_AMS","KaTeX_Caligraphic:n4,n7","KaTeX_Fraktur:n4,n7","KaTeX_Main:n4,n7,i4,i7","KaTeX_Math:i4,i7","KaTeX_Script","KaTeX_SansSerif:n4,n7,i4","KaTeX_Size1","KaTeX_Size2","KaTeX_Size3","KaTeX_Size4","KaTeX_Typewriter"]},active:()=>{e().refreshHook.call()}}})(()=>window.markmap)</script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" defer></script><script>(()=>{setTimeout(()=>{const{markmap:Fe,mm:ur}=window,Fr=new Fe.Toolbar;Fr.attach(ur);const Dr=Fr.render();Dr.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(Dr)})})()</script><script>((B,S,M,_)=>{const I=B();window.mm=I.Markmap.create("svg#mindmap",(S||I.deriveOptions)(_),M)})(()=>window.markmap,null,{"type":"heading","depth":0,"payload":{"lines":[1,2]},"content":"Knowledge representation and reasoning","children":[{"type":"heading","depth":1,"payload":{"lines":[7,8]},"content":"Lecture 1 : Agents and Environments","children":[{"type":"heading","depth":2,"payload":{"lines":[9,10]},"content":"Introduction to Agents and Environments","children":[{"type":"heading","depth":3,"payload":{"lines":[10,11]},"content":"PEAS (Performance measure, Environment, Actuators, Sensors) is a useful concept to consider when designing a rational agent"},{"type":"heading","depth":3,"payload":{"lines":[11,12]},"content":"Agents include humans, robots, softbots, thermostats, etc."},{"type":"heading","depth":3,"payload":{"lines":[12,13]},"content":"Agents map from percept histories to actions"},{"type":"heading","depth":3,"payload":{"lines":[13,14]},"content":"When designing an automated taxi, performance measures include safety, destination, profits, legality, comfort"},{"type":"heading","depth":3,"payload":{"lines":[14,15]},"content":"Environment for the automated taxi task includes US streets/freeways, traffic, pedestrians, weather"},{"type":"heading","depth":3,"payload":{"lines":[15,16]},"content":"Actuators for the automated taxi task include steering, accelerator, brake, horn, speaker/display"},{"type":"heading","depth":3,"payload":{"lines":[16,17]},"content":"Sensors for the automated taxi task include camera, GPS, LIDAR, ultrasound, odometer, etc."}]},{"type":"heading","depth":2,"payload":{"lines":[18,19]},"content":"Designing Rational Agents","children":[{"type":"heading","depth":3,"payload":{"lines":[19,20]},"content":"To design a rational agent, there must be a specified task environment, performance measure, actuators, and sensors."},{"type":"heading","depth":3,"payload":{"lines":[20,21]},"content":"Performance measure could include safety, destination, profits, legality, comfort, etc."},{"type":"heading","depth":3,"payload":{"lines":[21,22]},"content":"Actuators could include steering, accelerator, brake, horn, speaker/display, etc."},{"type":"heading","depth":3,"payload":{"lines":[22,23]},"content":"Sensors could include video, accelerometers, gauges, engine sensors, keyboard, GPS, etc."},{"type":"heading","depth":3,"payload":{"lines":[23,24]},"content":"In the case of an internet shopping agent, the performance measure could include price, quality, appropriateness, and efficiency."},{"type":"heading","depth":3,"payload":{"lines":[24,25]},"content":"The environment could include current and future WWW sites, vendors, and shippers."},{"type":"heading","depth":3,"payload":{"lines":[25,26]},"content":"Actuators could include display to user, follow URL, and fill in form."},{"type":"heading","depth":3,"payload":{"lines":[26,27]},"content":"Sensors could include HTML pages (text, graphics, scripts)."},{"type":"heading","depth":3,"payload":{"lines":[27,28]},"content":"Environment types can be fully observable, where the agent's sensors give it access to the complete state at each point in time."}]},{"type":"heading","depth":2,"payload":{"lines":[29,30]},"content":"Environment Types","children":[{"type":"heading","depth":3,"payload":{"lines":[30,31]},"content":"Partially observable: environment with noisy and inaccurate sensors or missing sensor data"},{"type":"heading","depth":3,"payload":{"lines":[31,32]},"content":"Single-agent vs. multiagent: single agent solves task independently, multiagent requires two agents interacting"},{"type":"heading","depth":3,"payload":{"lines":[32,33]},"content":"Deterministic vs. stochastic: next state of environment is either determined or uncertain"},{"type":"heading","depth":3,"payload":{"lines":[33,34]},"content":"Episodic vs. sequential: tasks divided into atomic episodes, next episode independent of previous"},{"type":"heading","depth":3,"payload":{"lines":[34,35]},"content":"Static vs. dynamic: environment changes while agent is deliberating, or agent's performance score changes but environment does not"},{"type":"heading","depth":3,"payload":{"lines":[35,36]},"content":"Semidynamic: environment does not change with time, but agent's performance score does."}]},{"type":"heading","depth":2,"payload":{"lines":[37,38]},"content":"Environment Types","children":[{"type":"heading","depth":3,"payload":{"lines":[38,39]},"content":"Solitaire, Backgammon, Internet Shopping, and Taxi are environment types with characteristics such as observable, deterministic, episodic, static, discrete, and single-agent."},{"type":"heading","depth":3,"payload":{"lines":[39,40]},"content":"Crossword puzzle, Chess with a clock, Poker, Backgammon, Taxi driving, Medical diagnosis, Image analysis, Part-picking robot, Refinery controller, and Interactive English tutor are task environments with observable, deterministic, episodic, static, discrete, and single-agent characteristics."},{"type":"heading","depth":3,"payload":{"lines":[40,41]},"content":"The environment type largely determines the agent design."},{"type":"heading","depth":3,"payload":{"lines":[41,42]},"content":"The real world is partially observable, stochastic, sequential, dynamic, continuous, and multi-agent."}]},{"type":"heading","depth":2,"payload":{"lines":[43,44]},"content":"Agent Types and Task Environments","children":[{"type":"heading","depth":3,"payload":{"lines":[44,45]},"content":"Simple reflex agents select actions based on the current percept and ignore the percept history."},{"type":"heading","depth":3,"payload":{"lines":[45,46]},"content":"Model-based reflex agents maintain an internal state which reflects the unobserved aspects of the current state."},{"type":"heading","depth":3,"payload":{"lines":[46,47]},"content":"Goal-based agents are used to achieve predetermined goals, while utility-based agents prioritize tasks according to their utility."},{"type":"heading","depth":3,"payload":{"lines":[47,48]},"content":"Task environments can be fully, partially, or semi-continuous, dynamic or static, discrete or continuous, single or multi-stochastic."},{"type":"heading","depth":3,"payload":{"lines":[48,49]},"content":"Agents can be used to learn by keeping track of the current state of the world using an internal model."}]},{"type":"heading","depth":2,"payload":{"lines":[50,51]},"content":"Agent Types: Utility-based and Goal-based Agents","children":[{"type":"heading","depth":3,"payload":{"lines":[51,52]},"content":"Utility-based agents need a performance measure that assigns a score to any given sequence of environment states, so it can easily distinguish between more and less desirable ways of getting to the agent's destination."},{"type":"heading","depth":3,"payload":{"lines":[52,53]},"content":"Goal-based agents need some sort of goal information that describes situations that are desirable, in addition to a current state description."},{"type":"heading","depth":3,"payload":{"lines":[53,54]},"content":"Learning agents can operate in initially unknown environments and become more competent than initial knowledge alone would allow."},{"type":"heading","depth":3,"payload":{"lines":[54,55]},"content":"Learning elements include problem generator, performance element, learning goals, and critic feedback."}]},{"type":"heading","depth":2,"payload":{"lines":[56,57]},"content":"Learning Agents","children":[{"type":"heading","depth":3,"payload":{"lines":[57,58]},"content":"Learning agents can be divided into four components: a learning element responsible for making improvements, a performance element responsible for selecting external actions, a critic element that provides feedback to the learning element on the agent's performance, and a problem generator that suggests exploratory actions."},{"type":"heading","depth":3,"payload":{"lines":[58,59]},"content":"Agents interact with environments through actuators and sensors and the agent function describes what the agent does in all circumstances."},{"type":"heading","depth":3,"payload":{"lines":[59,60]},"content":"The performance measure evaluates the environment sequence and a perfectly rational agent maximizes expected performance."},{"type":"heading","depth":3,"payload":{"lines":[60,61]},"content":"PEAS descriptions define task environments and environments are categorized along several dimensions: observable, deterministic, episodic, static, discrete, and single-agent."},{"type":"heading","depth":3,"payload":{"lines":[61,62]},"content":"Several basic agent architectures exist, such as reflex agents, reflex agents with state, goal-based agents, and utility-based agents."}]}]},{"type":"heading","depth":1,"payload":{"lines":[65,66]},"content":"lecture 01 practice :","children":[{"type":"heading","depth":2,"payload":{"lines":[67,68]},"content":"Converting Sentences to CNF","children":[{"type":"heading","depth":3,"payload":{"lines":[68,69]},"content":"Convert the left-hand side of the main implication into CNF: (-Food V Party) V (-Drinks V Party) (-Food V Party V -Drinks V Party) (-Food V -Drinks V Party)"},{"type":"heading","depth":3,"payload":{"lines":[69,70]},"content":"Convert the right-hand side of the main implication into CNF: (Food &amp; Drinks) ⇒ Party (Food V -Drinks V Party)"},{"type":"heading","depth":3,"payload":{"lines":[70,71]},"content":"Determine the validity of the sentence: A simple truth table shows the sentence is true for all models and hence valid"},{"type":"heading","depth":3,"payload":{"lines":[71,72]},"content":"Prove the answer using resolution: (Food V -Drinks V Party) ^ (-Food V -Drinks V Party) ⇒ Party"}]},{"type":"heading","depth":2,"payload":{"lines":[73,74]},"content":"Proving Validity of PP Using Resolution","children":[{"type":"heading","depth":3,"payload":{"lines":[74,75]},"content":"Negate the sentence, then convert it to CNF to prove unsatisfiability."},{"type":"heading","depth":3,"payload":{"lines":[75,76]},"content":"For the LHS use the CNF result: (-Food V -Drinks V Party) ^ Food &amp; Drinks -Party."},{"type":"heading","depth":3,"payload":{"lines":[76,77]},"content":"Each of the three unit clauses resolves in turn against the first clause, leaving an empty clause."},{"type":"heading","depth":3,"payload":{"lines":[77,78]},"content":"The empty clause denotes unsatisfiability, proving the validity of the original sentence in PP."}]}]},{"type":"heading","depth":1,"payload":{"lines":[82,83]},"content":"Lecture 2: Propositional Logic","children":[{"type":"heading","depth":2,"payload":{"lines":[84,85]},"content":"Truth Tables and Semantics of Propositional Logic","children":[{"type":"heading","depth":3,"payload":{"lines":[85,86]},"content":"Truth tables are used to specify the semantics of connectives (,, A, V, →) and compound sentences."},{"type":"heading","depth":3,"payload":{"lines":[86,87]},"content":"An interpretation of propositional logic is an assignment of either True or False to each proposition."},{"type":"heading","depth":3,"payload":{"lines":[87,88]},"content":"Given n propositions, there are 2^n possible interpretations (i.e. 2^n possible truth assignments)."},{"type":"heading","depth":3,"payload":{"lines":[88,89]},"content":"For example, if there are 5 propositions (i.e. P,Q,R,S,T), then there are 32 possible interpretations."},{"type":"heading","depth":3,"payload":{"lines":[89,90]},"content":"To compute the truth table (semantics) of a compound sentence, the truth table of the connectives can be used."},{"type":"heading","depth":3,"payload":{"lines":[90,91]},"content":"For example, the truth table of ((P VQ) A-Q) → P is: P Q ¬P PAQ PVQ P→ Q True False False True."}]},{"type":"heading","depth":2,"payload":{"lines":[92,93]},"content":"Natural Deduction","children":[{"type":"heading","depth":3,"payload":{"lines":[93,94]},"content":"Introduction to natural deduction, inference rules and models"},{"type":"heading","depth":3,"payload":{"lines":[94,95]},"content":"Valid sentences (tautologies or theorems) and satisfiability of sentences"},{"type":"heading","depth":3,"payload":{"lines":[95,96]},"content":"Contradiction and equivalence of sentences"},{"type":"heading","depth":3,"payload":{"lines":[96,97]},"content":"Inference rules: ^ introduction (^i), ^ elimination (^e1&amp;2), ✓ introduction (✓i1&amp;2), V elimination (Ve), → introduction (→i) &amp; elimination (→e)"},{"type":"heading","depth":3,"payload":{"lines":[97,98]},"content":"Example of the expression y1, y2, ..., yn a denotes that if we assume the truth of sentences y1, y2, . . . , yn then we can infer a"}]},{"type":"heading","depth":2,"payload":{"lines":[99,100]},"content":"Natural Deduction and Truth Tables","children":[{"type":"heading","depth":3,"payload":{"lines":[100,101]},"content":"Natural deduction is a method of inferring that a sentence is always true, without assuming anything."},{"type":"heading","depth":3,"payload":{"lines":[101,102]},"content":"To show that P,¬~(Q^R) |-¬¬P^R using natural deduction, we first assume the truth of P,¬~(Q^R), and then deduce a contradiction if it is both true and false."},{"type":"heading","depth":3,"payload":{"lines":[102,103]},"content":"To show the same using a truth table, we construct a truth table for P,¬~(Q^R), and extend it to show the values of P^R."},{"type":"heading","depth":3,"payload":{"lines":[103,104]},"content":"We then show that whenever P,¬~(Q^R) is true, P^R is also true."},{"type":"heading","depth":3,"payload":{"lines":[104,105]},"content":"This means that (P,¬~(Q^R)) → P^R is valid (i.e. always true)."}]},{"type":"heading","depth":2,"payload":{"lines":[106,107]},"content":"Propositional Logic Syntax Semantics &amp; Truth Tables Natural Deduction","children":[{"type":"heading","depth":3,"payload":{"lines":[107,108]},"content":"Propositional logic syntax consists of a sequence of True and False statements: True False False False False True True True False True False False False False True False False False False False False - False False False -"},{"type":"heading","depth":3,"payload":{"lines":[108,109]},"content":"Whenever PA⋀(Q⋁R) is true, so is ¬¬PAR, i.e. (PA⋀(Q⋁R)) →→PAR is valid."},{"type":"heading","depth":3,"payload":{"lines":[109,110]},"content":"Natural deduction is a method of deriving logical conclusions from given assumptions."},{"type":"heading","depth":3,"payload":{"lines":[110,111]},"content":"A truth table is a table of all possible inputs and outputs for a given proposition."}]},{"type":"heading","depth":2,"payload":{"lines":[113,114]},"content":"laws of propositional logic (jpg)","children":[{"type":"heading","depth":3,"payload":{"lines":[114,115]},"content":"De Morgan's laws: ¬(pv q ) = ¬ pvp = p"},{"type":"heading","depth":3,"payload":{"lines":[115,116]},"content":"Idempotent laws: pvq = q vp"},{"type":"heading","depth":3,"payload":{"lines":[116,117]},"content":"Associative laws: (pvq) v r = pv (qvr)"},{"type":"heading","depth":3,"payload":{"lines":[117,118]},"content":"Commutative laws: pv ( q ^ r ) = (pvq) ^ ( p vr)"},{"type":"heading","depth":3,"payload":{"lines":[118,119]},"content":"Distributive laws: pvF = p, PAF = F"},{"type":"heading","depth":3,"payload":{"lines":[119,120]},"content":"Identity laws: →→= PA¬pF¬T = F"},{"type":"heading","depth":3,"payload":{"lines":[120,121]},"content":"Domination laws: pv (p ^ q) = p"},{"type":"heading","depth":3,"payload":{"lines":[121,122]},"content":"Double negation law: pq= pv q"},{"type":"heading","depth":3,"payload":{"lines":[122,123]},"content":"Complement laws: ¬(p^ q ) = ¬ р^р=р"},{"type":"heading","depth":3,"payload":{"lines":[123,124]},"content":"Absorption laws: (p^ q) ^ r = p ^ (q^r)"},{"type":"heading","depth":3,"payload":{"lines":[124,125]},"content":"Conditional identities: p^q = q^ р, p^ ( qvr) = (p^q) v ( p^r), PAT = P, P v T = T, pvp = T, F = T, p ^ (p v q) = p, pq = ( p q ) ^ ( q → p)"}]}]},{"type":"heading","depth":1,"payload":{"lines":[135,136]},"content":"Lecture 3: More Reasoning in Propositional Logic","children":[{"type":"heading","depth":2,"payload":{"lines":[139,140]},"content":"Truth Tables and Semantics of Propositional Logic","children":[{"type":"heading","depth":3,"payload":{"lines":[140,141]},"content":"Truth tables are used to specify the semantics of connectives (,, A, V, →) and compound sentences."},{"type":"heading","depth":3,"payload":{"lines":[141,142]},"content":"An interpretation of propositional logic is an assignment of either True or False to each proposition."},{"type":"heading","depth":3,"payload":{"lines":[142,143]},"content":"Given n propositions, there are 2^n possible interpretations (i.e. 2^n possible truth assignments)."},{"type":"heading","depth":3,"payload":{"lines":[143,144]},"content":"For example, if there are 5 propositions (i.e. P,Q,R,S,T), then there are 32 possible interpretations."},{"type":"heading","depth":3,"payload":{"lines":[144,145]},"content":"To compute the truth table (semantics) of a compound sentence, the truth table of the connectives can be used."},{"type":"heading","depth":3,"payload":{"lines":[145,146]},"content":"For example, the truth table of ((P VQ) A-Q) → P is: P Q ¬P PAQ PVQ P→ Q True False False True."}]},{"type":"heading","depth":2,"payload":{"lines":[147,148]},"content":"Natural Deduction","children":[{"type":"heading","depth":3,"payload":{"lines":[148,149]},"content":"Introduction to natural deduction, inference rules and models"},{"type":"heading","depth":3,"payload":{"lines":[149,150]},"content":"Valid sentences (tautologies or theorems) and satisfiability of sentences"},{"type":"heading","depth":3,"payload":{"lines":[150,151]},"content":"Contradiction and equivalence of sentences"},{"type":"heading","depth":3,"payload":{"lines":[151,152]},"content":"Inference rules: ^ introduction (^i), ^ elimination (^e1&amp;2), ✓ introduction (✓i1&amp;2), V elimination (Ve), → introduction (→i) &amp; elimination (→e)"},{"type":"heading","depth":3,"payload":{"lines":[152,153]},"content":"Example of the expression y1, y2, ..., yn a denotes that if we assume the truth of sentences y1, y2, . . . , yn then we can infer a"}]},{"type":"heading","depth":2,"payload":{"lines":[154,155]},"content":"Natural Deduction and Truth Tables","children":[{"type":"heading","depth":3,"payload":{"lines":[155,156]},"content":"Natural deduction is a method of inferring that a sentence is always true, without assuming anything."},{"type":"heading","depth":3,"payload":{"lines":[156,157]},"content":"To show that P,¬~(Q^R) |-¬¬P^R using natural deduction, we first assume the truth of P,¬~(Q^R), and then deduce a contradiction if it is both true and false."},{"type":"heading","depth":3,"payload":{"lines":[157,158]},"content":"To show the same using a truth table, we construct a truth table for P,¬~(Q^R), and extend it to show the values of P^R."},{"type":"heading","depth":3,"payload":{"lines":[158,159]},"content":"We then show that whenever P,¬~(Q^R) is true, P^R is also true."},{"type":"heading","depth":3,"payload":{"lines":[159,160]},"content":"This means that (P,¬~(Q^R)) → P^R is valid (i.e. always true)."}]},{"type":"heading","depth":2,"payload":{"lines":[161,162]},"content":"Propositional Logic Syntax Semantics &amp; Truth Tables Natural Deduction","children":[{"type":"heading","depth":3,"payload":{"lines":[162,163]},"content":"Propositional logic syntax consists of a sequence of True and False statements: True False False False False True True True False True False False False False True False False False False False False - False False False -"},{"type":"heading","depth":3,"payload":{"lines":[163,164]},"content":"Whenever PA⋀(Q⋁R) is true, so is ¬¬PAR, i.e. (PA⋀(Q⋁R)) →→PAR is valid."},{"type":"heading","depth":3,"payload":{"lines":[164,165]},"content":"Natural deduction is a method of deriving logical conclusions from given assumptions."},{"type":"heading","depth":3,"payload":{"lines":[165,166]},"content":"A truth table is a table of all possible inputs and outputs for a given proposition."}]}]},{"type":"heading","depth":1,"payload":{"lines":[190,191]},"content":"Lecture 4: Introduction to Predicate Logic (also known as First-Order Logic)","children":[{"type":"heading","depth":2,"payload":{"lines":[192,193]},"content":"Predicate Logic: Terms, Predicates, and Blocks World","children":[{"type":"heading","depth":3,"payload":{"lines":[193,194]},"content":"Consider the concept of predicate logic: terms, predicates, and the blocks world."},{"type":"heading","depth":3,"payload":{"lines":[194,195]},"content":"Terms are logical expressions that refer to an object, such as constants, variables, and functions. Constants and functions are written with uppercase letter, while variables are written with lowercase letters."},{"type":"heading","depth":3,"payload":{"lines":[195,196]},"content":"Predicates are used to refer to properties of objects (unary predicates) and relationships among objects (n-ary predicates)."},{"type":"heading","depth":3,"payload":{"lines":[196,197]},"content":"For example, the blocks world can be described using constants and a predicate &quot;on&quot; which describes which object is on which. Additionally, a function &quot;Next&quot; can take an object and return the following object in a clockwise direction."}]},{"type":"heading","depth":2,"payload":{"lines":[198,199]},"content":"Predicate Logic: Complex Sentences","children":[{"type":"heading","depth":3,"payload":{"lines":[199,200]},"content":"Every BUID student is cool Vx, student_of (x, BUiD) → cool(x)"},{"type":"heading","depth":3,"payload":{"lines":[200,201]},"content":"Everybody likes icecream Vx, likes(x, IceCream)"},{"type":"heading","depth":3,"payload":{"lines":[201,202]},"content":"There exists (at least one) cool student in BUiD 3x, student of (x, BUID) A cool(x)"},{"type":"heading","depth":3,"payload":{"lines":[202,203]},"content":"There is no body who does not like icecream -3x, likes(x, IceCream)"},{"type":"heading","depth":3,"payload":{"lines":[203,204]},"content":"Variables begin with lower-case letters"},{"type":"heading","depth":3,"payload":{"lines":[204,205]},"content":"Universal Quantification (V) and Existential Quantification (3)"},{"type":"heading","depth":3,"payload":{"lines":[205,206]},"content":"Formula for Predicate Logic form ::= pred (term_list) | -form | form V form | form A form | form → form | Vvar form | 3var form"},{"type":"heading","depth":3,"payload":{"lines":[206,207]},"content":"Examples: Vx frog(x) green(x) and Vx frog(x) A brown(x) ⇒ big(x)"},{"type":"heading","depth":3,"payload":{"lines":[207,208]},"content":"Everyone likes cake Vx likes(x, cake)"},{"type":"heading","depth":3,"payload":{"lines":[208,209]},"content":"Not everyone likes cake -Vx likes(x, cake)"}]},{"type":"heading","depth":2,"payload":{"lines":[210,211]},"content":"Understanding Logical Formulas and Their Examples","children":[{"type":"heading","depth":3,"payload":{"lines":[211,212]},"content":"All frogs are green, all brown frogs are big, everyone likes cake, not everyone likes cake and no one likes cake"},{"type":"heading","depth":3,"payload":{"lines":[212,213]},"content":"There is something that everyone likes, there is someone who likes everything, everything is loved by someone, everyone likes something and Bob likes every customer"},{"type":"heading","depth":3,"payload":{"lines":[213,214]},"content":"Formulas include: Vx frog(x) green(x), Vx frog(x) A brown(x) ⇒ big(x), Vx likes(x, cake), -Vx likes(x, cake), -Ex likes(x, cake), Ex Vy likes(y,x), Ex Vy likes(x, y), Vx ‡y likes(y, x), Vx y likes(x, y), Vx customer(x) ⇒ likes(bob, x), Ex customer(x) ^ likes(x, bob) and Ex baker(x) ^ Vy customer(y) ⇒ likes(x, y)"}]},{"type":"heading","depth":2,"payload":{"lines":[215,216]},"content":"Semantics of Predicate Logic","children":[{"type":"heading","depth":3,"payload":{"lines":[216,217]},"content":"Interpretation of a Predicate Logic Language is a mapping from the elements of the language to elements of a structure"},{"type":"heading","depth":3,"payload":{"lines":[217,218]},"content":"Validity: A formula u is valid if it is true under all interpretations and all variable assignments"},{"type":"heading","depth":3,"payload":{"lines":[218,219]},"content":"Satisfaction: A formula y is satisfiable if there is some interpretation &amp; a variable assignment under which w is true"},{"type":"heading","depth":3,"payload":{"lines":[219,220]},"content":"Contradiction: A formula y is contradictory if there is no interpretation &amp; a variable assignment under which w is true"},{"type":"heading","depth":3,"payload":{"lines":[220,221]},"content":"Semantics of function F symbol with terms t1, . . . , tn: IF(t1,..., tn) iff I(F)(I(t1), ..., I (tn)) is defined"},{"type":"heading","depth":3,"payload":{"lines":[221,222]},"content":"Semantics of predicate p with terms tl, I ‡p(t1, ..., tn) iff I(p)(I(t1), ..., I (tn)) is defined"},{"type":"heading","depth":3,"payload":{"lines":[222,223]},"content":"Knowledge Eng. in Predicate Logic consists of identifying the task and specifying the relevant language elements."}]},{"type":"heading","depth":2,"payload":{"lines":[224,225]},"content":"Knowledge Engineering in Predicate Logic","children":[{"type":"heading","depth":3,"payload":{"lines":[225,226]},"content":"Readings: 8.1 &amp; 8.2 from R&amp;N provide an overview of the concepts of predicate logic and its use in knowledge engineering"},{"type":"heading","depth":3,"payload":{"lines":[226,227]},"content":"To understand the scope of the knowledge base, relevant knowledge must be assembled and a vocabulary (ontology) must be determined, including constants, functions, and predicates"},{"type":"heading","depth":3,"payload":{"lines":[227,228]},"content":"General domain knowledge must be encoded as &quot;axioms&quot; (rules that always hold); for instance: &quot;all BUID students are cool&quot;"},{"type":"heading","depth":3,"payload":{"lines":[228,229]},"content":"To encode the description of a specific problem instance, simple atomic sentences about the concepts in the ontology must be written"},{"type":"heading","depth":3,"payload":{"lines":[229,230]},"content":"Queries can then be posed to the inference procedure to get answers; e.g. &quot;is Omar cool?&quot;"},{"type":"heading","depth":3,"payload":{"lines":[230,231]},"content":"Predicate logic syntax and semantics must be understood, as well as the semantic entailment of FOL formulas"},{"type":"heading","depth":3,"payload":{"lines":[231,232]},"content":"An example of interpreting a predicate logic language for the blocks world is provided, with constants, a function symbol, and a predicate"}]},{"type":"heading","depth":2,"payload":{"lines":[233,234]},"content":"Semantics of Quantified Formulas","children":[{"type":"heading","depth":3,"payload":{"lines":[234,235]},"content":"The semantics of quantified formulas is defined such that on: S × S where: on = {(e, c), (c, a), (e, d), (d, b), (b, base), (a, base)} and next: S → S where: next(base) = a, next(a) = C, next(c) = e, next(e) = d, next(d) = b, next(b) = base."},{"type":"heading","depth":3,"payload":{"lines":[235,236]},"content":"Let Þ(vn) denote some formula that contains variables v1, ... , Then, the semantics of quantified formulas is defined as follows: I =\\vn (Þ(vn)) iff I ‡ Þ(vn) for all assignments of vn to an objects."},{"type":"heading","depth":3,"payload":{"lines":[236,237]},"content":"I ‡‡vn (Þ(vn)) iff I ‡Þ(vn) for some assignment of vn to an object."},{"type":"heading","depth":3,"payload":{"lines":[237,238]},"content":"For example: B B Ě 3v1 on(A, v1) Vvlon(Base, v1)."}]}]},{"type":"heading","depth":1,"payload":{"lines":[251,252]},"content":"Lecture 5: Inference Techniques for Predicate Logic","children":[{"type":"heading","depth":2,"payload":{"lines":[253,254]},"content":"Reduction to Propositional Logic","children":[{"type":"heading","depth":3,"payload":{"lines":[254,255]},"content":"Reduction to Propositional Logic involves instantiating the universal sentence in all possible ways and creating proposition symbols to represent each instance."},{"type":"heading","depth":3,"payload":{"lines":[255,256]},"content":"The process of Reduction to Propositional Logic can be completed by using the (→e) inference rule to create new propositions."},{"type":"heading","depth":3,"payload":{"lines":[256,257]},"content":"Universal Instantiation is a FOL inference rule that allows for the substitution of a variable with a constant, resulting in a new sentence."},{"type":"heading","depth":3,"payload":{"lines":[257,258]},"content":"Existential Instantiation (or Elimination) is a FOL inference rule that allows for the substitution of a variable with a constant that does not appear elsewhere in the knowledge base."},{"type":"heading","depth":3,"payload":{"lines":[258,259]},"content":"Existential Introduction is a FOL inference rule that allows for the substitution of a constant or function symbol with a variable that does not occur in the sentence."}]},{"type":"heading","depth":2,"payload":{"lines":[260,261]},"content":"Prove that Colonel West is a Criminal","children":[{"type":"heading","depth":3,"payload":{"lines":[261,262]},"content":"American(x), weapon(y), sells(x,y,z), hostile(z) → criminal(x): Definite clause (1)"},{"type":"heading","depth":3,"payload":{"lines":[262,263]},"content":"owns(Nono, M1) and missile(M1): Existential elimination (2 &amp; 3)"},{"type":"heading","depth":3,"payload":{"lines":[263,264]},"content":"all of its missiles were sold to it by Colonel West: Definite clause (4)"},{"type":"heading","depth":3,"payload":{"lines":[264,265]},"content":"American(Colonel West), weapon(M1), sells(Colonel West, M1, Nono), hostile(Nono): Substitution (5)"},{"type":"heading","depth":3,"payload":{"lines":[265,266]},"content":"criminal(Colonel West): GMP (1 &amp; 5)"}]},{"type":"heading","depth":2,"payload":{"lines":[267,268]},"content":"Proving That Colonel West is a Criminal","children":[{"type":"heading","depth":3,"payload":{"lines":[268,269]},"content":"Missile(M1) and owns(Nono, M1) is established as a fact"},{"type":"heading","depth":3,"payload":{"lines":[269,270]},"content":"Missile(M1) implies weapon(M1) is established by rule (5)"},{"type":"heading","depth":3,"payload":{"lines":[270,271]},"content":"Enemy(Nono, America) implies hostile(Nono) is established by rule (6)"},{"type":"heading","depth":3,"payload":{"lines":[271,272]},"content":"American(West) is established as a fact"},{"type":"heading","depth":3,"payload":{"lines":[272,273]},"content":"Sells(West, M1, Nono) is established by rule (4)"},{"type":"heading","depth":3,"payload":{"lines":[273,274]},"content":"Law states american(x) ^ weapon(y) ^ sells(x, y, z) ^ hostile(z) → criminal(x)"},{"type":"heading","depth":3,"payload":{"lines":[274,275]},"content":"Therefore, Colonel West is a criminal"}]},{"type":"heading","depth":2,"payload":{"lines":[276,277]},"content":"Analysis of Forward and Backward Chaining","children":[{"type":"heading","depth":3,"payload":{"lines":[277,278]},"content":"Forward chaining is sound and complete for definite clause knowledge bases."},{"type":"heading","depth":3,"payload":{"lines":[278,279]},"content":"Backward chaining is an inference process that starts from a query, and applies GMP in a backward direction, adding new sub-goals."},{"type":"heading","depth":3,"payload":{"lines":[279,280]},"content":"The example knowledge base contains 8 sentences which describe it is a crime for an American to sell weapons to hostile nations."},{"type":"heading","depth":3,"payload":{"lines":[280,281]},"content":"Rule 1 is satisfied with x/West, y/M1, z/Nono."},{"type":"heading","depth":3,"payload":{"lines":[281,282]},"content":"Rule 2 and 3 are unified by owns(Nono, M1) and missile(M1)."},{"type":"heading","depth":3,"payload":{"lines":[282,283]},"content":"Rule 4 unifies sells(x,y,z) with West, x, Nono."},{"type":"heading","depth":3,"payload":{"lines":[283,284]},"content":"Rule 5 unifies weapon(y) with missile(x)."},{"type":"heading","depth":3,"payload":{"lines":[284,285]},"content":"Rule 6 unifies hostile(x) with enemy(Nono, America)."},{"type":"heading","depth":3,"payload":{"lines":[285,286]},"content":"Rule 7 unifies american(x) with american(West)."}]},{"type":"heading","depth":2,"payload":{"lines":[287,288]},"content":"Propositional Logic, Forward and Backward Chaining","children":[{"type":"heading","depth":3,"payload":{"lines":[288,289]},"content":"Propositional logic is used to reduce West, M1, and Nono missiles to unified hostile(z) goal."},{"type":"heading","depth":3,"payload":{"lines":[289,290]},"content":"Backward chaining is used to establish that West is a criminal, weapon(MI) and missile(M1) are owned by Nono, and hostile(Nono) is enemy(Nono, America)."},{"type":"heading","depth":3,"payload":{"lines":[290,291]},"content":"Forward chaining is used to unify hostile(Nano) with rule 6 that Vx, enemy(x, America) → hostile(x)."},{"type":"heading","depth":3,"payload":{"lines":[291,292]},"content":"Rule 8 is used to prove that enemy(Nono, America) is already unified."},{"type":"heading","depth":3,"payload":{"lines":[292,293]},"content":"Generalized Modus Ponens is used to summarize reduction to Propositional Logic."},{"type":"heading","depth":3,"payload":{"lines":[293,294]},"content":"This section is based on (Russell and Norvig) Sections 9.1-9.4"}]}]},{"type":"heading","depth":1,"payload":{"lines":[313,314]},"content":"Lecture 6: Logic based programming in PROLOG.","children":[{"type":"heading","depth":2,"payload":{"lines":[321,322]},"content":"PROLOG","children":[{"type":"heading","depth":3,"payload":{"lines":[322,323]},"content":"Prolog is a logical and declarative programming language and is widely used in research and education as well as commercial applications."},{"type":"heading","depth":3,"payload":{"lines":[323,324]},"content":"It has no global variables, no assignment statement and no real iterative constructs, but recursion is very central."},{"type":"heading","depth":3,"payload":{"lines":[324,325]},"content":"It is good for grammar and language processing, knowledge representation and reasoning, unification, pattern matching, planning and search."},{"type":"heading","depth":3,"payload":{"lines":[325,326]},"content":"It is not ideal for repetitive number crunching, representing complex data structures, and Input/Output (interfaces)."},{"type":"heading","depth":3,"payload":{"lines":[326,327]},"content":"GNU Prolog and SWI-Prolog are both free software available for download."},{"type":"heading","depth":3,"payload":{"lines":[327,328]},"content":"In Prolog, we tell the computer what problem we want to be solved, rather than how to solve it."}]},{"type":"heading","depth":2,"payload":{"lines":[329,330]},"content":"Working with Prolog: Facts, Rules, and Queries","children":[{"type":"heading","depth":3,"payload":{"lines":[330,331]},"content":"Facts: Explicit relationship between objects and properties these objects might have; names of properties/relationships begin with lower case letters; the relationship name appears as the first term; objects appear as comma-separated arguments within parentheses; a period &quot;.&quot; must end a fact; objects also begin with lower case letters."},{"type":"heading","depth":3,"payload":{"lines":[331,332]},"content":"Rules: Implicit relationship between objects; when one associated condition is true, then the predicate is also true; can use comma (,) as conjunction; can use semicolon as disjunction."},{"type":"heading","depth":3,"payload":{"lines":[332,333]},"content":"Queries: Questions on the relationships between objects and object properties."}]},{"type":"heading","depth":2,"payload":{"lines":[334,335]},"content":"Using Prolog","children":[{"type":"heading","depth":3,"payload":{"lines":[335,336]},"content":"Write your program away from the computer before typing it into a file with a .pl extension"},{"type":"heading","depth":3,"payload":{"lines":[336,337]},"content":"Open the Prolog environment and consult your file"},{"type":"heading","depth":3,"payload":{"lines":[337,338]},"content":"The content of the file will be stored in the memory of the Prolog interpreter"},{"type":"heading","depth":3,"payload":{"lines":[338,339]},"content":"Ask questions of your database"},{"type":"heading","depth":3,"payload":{"lines":[339,340]},"content":"If you edit the program file, be sure to consult it again afterwards"},{"type":"heading","depth":3,"payload":{"lines":[340,341]},"content":"To exit from Prolog type or press Control/D (Unix platform) or Control/z (Windows platform)"},{"type":"heading","depth":3,"payload":{"lines":[341,342]},"content":"Use single or multi-line comments with % or /* % and */"},{"type":"heading","depth":3,"payload":{"lines":[342,343]},"content":"Always have a file header with filename, author, date, version, and purpose"}]}]},{"type":"heading","depth":1,"payload":{"lines":[354,355]},"content":"Lecture 7: Prolog Fundamentals","children":[{"type":"heading","depth":2,"payload":{"lines":[358,359]},"content":"Fundamentals","children":[{"type":"heading","depth":3,"payload":{"lines":[359,360]},"content":"Predicate definitions consist of facts and rules, with a head and sometimes a body."},{"type":"heading","depth":3,"payload":{"lines":[360,361]},"content":"Predicate heads contain a predicate name and arguments, which can be constants, variables, or compound terms."},{"type":"heading","depth":3,"payload":{"lines":[361,362]},"content":"Constants can be numbers, symbolic constants, or string constants."},{"type":"heading","depth":3,"payload":{"lines":[362,363]},"content":"Variables always start with an upper case letter or underscore."},{"type":"heading","depth":3,"payload":{"lines":[363,364]},"content":"Facts assert some property of an object, or relation between two or more objects."},{"type":"heading","depth":3,"payload":{"lines":[364,365]},"content":"Rules allow us to infer that a property or relationship holds based on preconditions."},{"type":"heading","depth":3,"payload":{"lines":[365,366]},"content":"Order of arguments is arbitrary but must remain consistent."}]},{"type":"heading","depth":2,"payload":{"lines":[367,368]},"content":"Predicate Definitions, Arity and Variables","children":[{"type":"heading","depth":3,"payload":{"lines":[368,369]},"content":"Predicate definitions can automate commands in Prolog."},{"type":"heading","depth":3,"payload":{"lines":[369,370]},"content":"The number of arguments a predicate has is called its arity."},{"type":"heading","depth":3,"payload":{"lines":[370,371]},"content":"A predicate is uniquely identified by its name and arity."},{"type":"heading","depth":3,"payload":{"lines":[371,372]},"content":"Different clauses can be used to deal with different arguments."},{"type":"heading","depth":3,"payload":{"lines":[372,373]},"content":"Variables can be used in questions and the variable will be instantiated to the value of the closest clause."}]},{"type":"heading","depth":2,"payload":{"lines":[374,375]},"content":"Unification, Retrying Goals, and Variable Clause Head","children":[{"type":"heading","depth":3,"payload":{"lines":[375,376]},"content":"When two terms match we say that they unify. Their structures and arguments are compatible. This can be checked using =/2."},{"type":"heading","depth":3,"payload":{"lines":[376,377]},"content":"Re-trying Goals: if a question is asked with a variable as an argument, we can ask the Prolog interpreter for multiple answers using &quot;; | ?- greet (Anybody)&quot;."},{"type":"heading","depth":3,"payload":{"lines":[377,378]},"content":"Variable clause head: if greet/1 is called with a constant other than hamish or amelia it will fail (return no). We can create a default case that always succeeds by writing a clause with a variable as the head argument."},{"type":"heading","depth":3,"payload":{"lines":[378,379]},"content":"Ordering of clauses: the most specific clause should always be at the top, with general clauses (containing variables) at the bottom."},{"type":"heading","depth":3,"payload":{"lines":[379,380]},"content":"Asking questions of the database: we can ask about facts directly using &quot;|?- mother (X, alan).&quot;"}]},{"type":"heading","depth":2,"payload":{"lines":[381,382]},"content":"Prolog Program Overview","children":[{"type":"heading","depth":3,"payload":{"lines":[382,383]},"content":"Prolog programs consist of predicate definitions, which denote a property or relationship between objects."},{"type":"heading","depth":3,"payload":{"lines":[383,384]},"content":"Definitions consist of clauses, which have a head and a body (Rule) or just a head (Fact)."},{"type":"heading","depth":3,"payload":{"lines":[384,385]},"content":"A head consists of a predicate name and arguments, while a clause body consists of a conjunction of terms."},{"type":"heading","depth":3,"payload":{"lines":[385,386]},"content":"Terms can be constants, variables, or compound terms."},{"type":"heading","depth":3,"payload":{"lines":[386,387]},"content":"Goals are set by typing a command that unifies with a clause head."},{"type":"heading","depth":3,"payload":{"lines":[387,388]},"content":"Goal unification is top-down and leads to the instantiation of variables to values."},{"type":"heading","depth":3,"payload":{"lines":[388,389]},"content":"Unification occurs using =/2, read/1, or between arguments during parameter passing."},{"type":"heading","depth":3,"payload":{"lines":[389,390]},"content":"When variables in the initial goal become instantiated, this is reported back to the user."}]}]},{"type":"heading","depth":1,"payload":{"lines":[406,407]},"content":"Lecture 8: Tests, Backtracking","children":[{"type":"heading","depth":2,"payload":{"lines":[410,411]},"content":"Correction:","children":[{"type":"heading","depth":3,"payload":{"lines":[411,412]},"content":"Re-trying Goals When a question is asked with a variable as an argument, we can ask the Prolog interpreter for multiple answers."}]},{"type":"heading","depth":2,"payload":{"lines":[413,414]},"content":"Fundamentals:","children":[{"type":"heading","depth":3,"payload":{"lines":[414,415]},"content":"Tests: When we ask Prolog a question, we are asking for the interpreter to prove that the statement is true."},{"type":"heading","depth":3,"payload":{"lines":[415,416]},"content":"Unification: Equality is different from unification."},{"type":"heading","depth":3,"payload":{"lines":[416,417]},"content":"Arithmetic Operators: +, *./ Need to use is to access result of the arithmetic expression otherwise it is treated as a term."},{"type":"heading","depth":3,"payload":{"lines":[417,418]},"content":"Mathematical precedence is preserved."},{"type":"heading","depth":3,"payload":{"lines":[418,419]},"content":"Compound sums using round brackets can be used to impose new precedence."},{"type":"heading","depth":3,"payload":{"lines":[419,420]},"content":"Knowledge Base 1: Priya is a girl and can cook - Jaya is a girl and cannot cook."},{"type":"heading","depth":3,"payload":{"lines":[420,421]},"content":"Change Directory: 'D: /TP Prolog/Sample_Codes'."}]},{"type":"heading","depth":2,"payload":{"lines":[422,423]},"content":"Understanding Backtracking","children":[{"type":"heading","depth":3,"payload":{"lines":[423,424]},"content":"Backtracking is a process of finding a proper destination by trying different paths until the destination is found."},{"type":"heading","depth":3,"payload":{"lines":[424,425]},"content":"When a destination is found, the backtracking process stops."},{"type":"heading","depth":3,"payload":{"lines":[425,426]},"content":"Predicates are used to represent relationships in a Family Tree."},{"type":"heading","depth":3,"payload":{"lines":[426,427]},"content":"Examples of predicates are mother, sister, uncle, grandparent, and wife."},{"type":"heading","depth":3,"payload":{"lines":[427,428]},"content":"Backtracking can be visualized using a sample Family Tree."},{"type":"heading","depth":3,"payload":{"lines":[428,429]},"content":"An example of backtracking is finding the bigger number between two numbers."},{"type":"heading","depth":3,"payload":{"lines":[429,430]},"content":"When the destination is not found, backtracking will go back to the previous node and try another path until the destination is found."}]},{"type":"heading","depth":2,"payload":{"lines":[431,432]},"content":"Backtracking and Writing of Prolog Conditions","children":[{"type":"heading","depth":3,"payload":{"lines":[432,433]},"content":"Prolog conditions can be written and tested through backtracking."},{"type":"heading","depth":3,"payload":{"lines":[433,434]},"content":"A query is posed to the program with the condition of &quot;bigger (5,5)&quot;."},{"type":"heading","depth":3,"payload":{"lines":[434,435]},"content":"If the query only matches the final clause, then the condition is &quot;N"},{"type":"heading","depth":3,"payload":{"lines":[435,436]},"content":"If the condition is satisfied, then the program will write &quot;The bigger number is M&quot;."},{"type":"heading","depth":3,"payload":{"lines":[436,437]},"content":"If the condition is not satisfied, then the program will write &quot;The bigger number is N&quot;."},{"type":"heading","depth":3,"payload":{"lines":[437,438]},"content":"If the conditions are the same, then the program will write &quot;Numbers are the same&quot;."}]}]},{"type":"heading","depth":1,"payload":{"lines":[459,460]},"content":"Lecture 9: Exercises on facts, rules and Recursion","children":[{"type":"heading","depth":2,"payload":{"lines":[462,463]},"content":"Writing Facts, Rules, and Programs to Represent Knowledge","children":[{"type":"heading","depth":3,"payload":{"lines":[463,464]},"content":"Create facts to represent descriptions, such as death, taxes, exams, the earth's shape, and ownership of a Volkswagen."},{"type":"heading","depth":3,"payload":{"lines":[464,465]},"content":"Write rules to represent descriptions, such as where there's smoke there's fire, and for determining if someone is happy."},{"type":"heading","depth":3,"payload":{"lines":[465,466]},"content":"Write a predicate mathtable/3 to define a multiplication table for integers between 1 and 4."},{"type":"heading","depth":3,"payload":{"lines":[466,467]},"content":"Create a predicate abs(X,Y) to take a number X as input and compute the absolute value |X| as output."},{"type":"heading","depth":3,"payload":{"lines":[467,468]},"content":"Program to find the roots of a quadratic equation: ax² + bx + c = 0."},{"type":"heading","depth":3,"payload":{"lines":[468,469]},"content":"Write a program to store information about your family and answer queries about relationships."}]},{"type":"heading","depth":2,"payload":{"lines":[470,471]},"content":"Querying Individual People","children":[{"type":"heading","depth":3,"payload":{"lines":[471,472]},"content":"Given a definition of a Person (Person, Sex, Parent), this text outlines various queries that can be made about individual people."},{"type":"heading","depth":3,"payload":{"lines":[472,473]},"content":"To answer query A. ? parent(Person, Parent), either the mother or the father is hinted at."},{"type":"heading","depth":3,"payload":{"lines":[473,474]},"content":"For query B. ? father(Person, Father) and C. ? mother(Person, Mother), person(Person,<em>Sex,Parent) and person(Father/Mother,male/female,</em>) respectively must be used."},{"type":"heading","depth":3,"payload":{"lines":[474,475]},"content":"To answer query D. ? sibling (Person, Sibling), siblings must have the same parent, so person(Person,_Sex, Parent) and person(Sibling,_Sex, Parent) is used."},{"type":"heading","depth":3,"payload":{"lines":[475,476]},"content":"Query E. ? brother(Person, Brother) and F. ? sister(Person, Sister) can be answered with person(Person,_Sex, Parent), person (Brother/Sister, male/female, Parent)."},{"type":"heading","depth":3,"payload":{"lines":[476,477]},"content":"Query G. ? offspring(Person, Offspring) is the inverse of parent, so offspring (Person,Offspring):- parent(Offspring, Person)."},{"type":"heading","depth":3,"payload":{"lines":[477,478]},"content":"For query H. ? son(Person, Son) and I. ? daughter(Person, Daughter), person(Son/Daughter, male/female, Person) or offspring (Person,Son/Daughter), person(Son/Daughter, male/female,_) is used."},{"type":"heading","depth":3,"payload":{"lines":[478,479]},"content":"Query J. ?aunt(Person, Aunt) and K. ? uncle(Person, Uncle) is answered using parent(Person, Parent), sister(Parent, Aunt) and brother(Parent, Uncle) respectively."},{"type":"heading","depth":3,"payload":{"lines":[479,480]},"content":"Query L. ? nephew(Person, Nephew) and M. ? niece(Person, Niece) can be answered with sibling (Person, Sibling), son(Sibling, Nephew) and daughter(Sibling, Niece)."},{"type":"heading","depth":3,"payload":{"lines":[480,481]},"content":"Query N. ? descendant(Person, Descendant) is a descendant or a descendant's offspring, so descendant(Person, Descendant) :- offspring (Person, Descendant)."},{"type":"heading","depth":3,"payload":{"lines":[481,482]},"content":"Finally, query O. ? ancestor (Person, Ancestor) is the inverse of descendant, so ancestor(Person, Ancestor):- descendant(Ancestor, Person) or parent(Person, Ancestor)."}]}]},{"type":"heading","depth":1,"payload":{"lines":[502,503]},"content":"Lecture 10: Using Prolog to encode knowledge","children":[{"type":"heading","depth":2,"payload":{"lines":[505,506]},"content":"Working with Prolog Data Objects and Structures","children":[{"type":"heading","depth":3,"payload":{"lines":[506,507]},"content":"Prolog data objects include atoms, constants, numbers, and variables."},{"type":"heading","depth":3,"payload":{"lines":[507,508]},"content":"Structured objects are constructed from a functor (constant symbol) and components which can be of any type."},{"type":"heading","depth":3,"payload":{"lines":[508,509]},"content":"Recursive data structures allow Prolog to perform complex search of a problem space without any dedicated algorithms."},{"type":"heading","depth":3,"payload":{"lines":[509,510]},"content":"Strings and lists are examples of Prolog data structures."},{"type":"heading","depth":3,"payload":{"lines":[510,511]},"content":"Structure unification occurs when the functors are the same, they have the same number of components, and all components unify."},{"type":"heading","depth":3,"payload":{"lines":[511,512]},"content":"A structure may also have another structure as a component, and unification works recursively."},{"type":"heading","depth":3,"payload":{"lines":[512,513]},"content":"A list is a collection of ordered data, enclosed by square brackets and separated by commas."}]},{"type":"heading","depth":2,"payload":{"lines":[514,515]},"content":"Unifying Structures and Lists","children":[{"type":"heading","depth":3,"payload":{"lines":[515,516]},"content":"Structures can be unified with variables then used as commands."},{"type":"heading","depth":3,"payload":{"lines":[516,517]},"content":"Lists can store ordered data and allow its sequential processing through recursion."},{"type":"heading","depth":3,"payload":{"lines":[517,518]},"content":"Two lists unify if they are the same length and all their elements unify."},{"type":"heading","depth":3,"payload":{"lines":[518,519]},"content":"Lists are recursively defined structures."},{"type":"heading","depth":3,"payload":{"lines":[519,520]},"content":"The bar notation [Head | Tail] turns everything after the Head into a list and unifies it with Tail."},{"type":"heading","depth":3,"payload":{"lines":[520,521]},"content":"Head must unify with a single term and Tail unifies with a list of any length, including an empty list, []."},{"type":"heading","depth":3,"payload":{"lines":[521,522]},"content":"The bar notation is used to represent recursive data structures."}]}]},{"type":"heading","depth":1,"payload":{"lines":[532,533]},"content":"Lecture 11: List Processing","children":[{"type":"heading","depth":2,"payload":{"lines":[536,537]},"content":"List Processing Using Recursion","children":[{"type":"heading","depth":3,"payload":{"lines":[537,538]},"content":"Identifying a list as a recursively defined structure can be tested using the Head and Tail notation."},{"type":"heading","depth":3,"payload":{"lines":[538,539]},"content":"A recursive definition needs two things – a base case and a recursive case."},{"type":"heading","depth":3,"payload":{"lines":[539,540]},"content":"The recursive case must move the problem closer to a solution to avoid infinite loops."},{"type":"heading","depth":3,"payload":{"lines":[540,541]},"content":"With list processing this means stripping away the Head of a list and recursing on the Tail."},{"type":"heading","depth":3,"payload":{"lines":[541,542]},"content":"Focussed recursion is also necessary when recursing to find a property, to avoid infinite loops."},{"type":"heading","depth":3,"payload":{"lines":[542,543]},"content":"A query looking for all solutions will loop if the recursive case does not focus the search."}]},{"type":"heading","depth":2,"payload":{"lines":[544,545]},"content":"List Processing Predicates: Member/2","children":[{"type":"heading","depth":3,"payload":{"lines":[545,546]},"content":"Member/2 checks if a term is an element of a list, returning yes if it is and fails if it isn't."},{"type":"heading","depth":3,"payload":{"lines":[546,547]},"content":"1st clause checks if the Head of the list unifies with the first argument; if yes then succeeds, if no then fail."},{"type":"heading","depth":3,"payload":{"lines":[547,548]},"content":"2nd clause ignores the Head and recurses on the Tail."},{"type":"heading","depth":3,"payload":{"lines":[548,549]},"content":"To trace Prolog execution of a goal, type trace at the command line."},{"type":"heading","depth":3,"payload":{"lines":[549,550]},"content":"To turn off the tracer type notrace."}]},{"type":"heading","depth":2,"payload":{"lines":[551,552]},"content":"Collecting Results in Prolog","children":[{"type":"heading","depth":3,"payload":{"lines":[552,553]},"content":"Compute the result at the base case first, then use this result as you backtrack through the program (backward)."},{"type":"heading","depth":3,"payload":{"lines":[553,554]},"content":"Accumulate a result as you recurse into the program and finalise it at the base case (forward)."},{"type":"heading","depth":3,"payload":{"lines":[554,555]},"content":"Recurse on an uninstantiated variable and accumulate results on backtracking (separate argument)."},{"type":"heading","depth":3,"payload":{"lines":[555,556]},"content":"Efficiency can be realized by relying on tail-recursive predicates (i.e. recursion only at the last goal)."},{"type":"heading","depth":3,"payload":{"lines":[556,557]},"content":"Initialise a counter to zero in the base case, then increase it as you backtrack."},{"type":"heading","depth":3,"payload":{"lines":[557,558]},"content":"Trace the execution of the program to check that it is working as expected."},{"type":"heading","depth":3,"payload":{"lines":[558,559]},"content":"Changing the order of the predicates can cause errors and fail to accumulate results."},{"type":"heading","depth":3,"payload":{"lines":[559,560]},"content":"Using an accumulator to accumulate results as you recurse into the program, then finalise it at the base."}]},{"type":"heading","depth":2,"payload":{"lines":[561,562]},"content":"Combining Lists with an Accumulator","children":[{"type":"heading","depth":3,"payload":{"lines":[562,563]},"content":"When using an accumulator, the initialised value must be correct (e.g. [] or 0)."},{"type":"heading","depth":3,"payload":{"lines":[563,564]},"content":"To combine two lists, an auxiliary predicate with the accumulator is used."},{"type":"heading","depth":3,"payload":{"lines":[564,565]},"content":"The accumulator is initialised correctly and the user doesn't have to understand the workings of the code."},{"type":"heading","depth":3,"payload":{"lines":[565,566]},"content":"To add L1 to L2, the bar notation is used to decompose L1 and add the Head to L2."},{"type":"heading","depth":3,"payload":{"lines":[566,567]},"content":"An extra variable (Out) is used to pass back the new list once L1 is empty."}]},{"type":"heading","depth":2,"payload":{"lines":[568,569]},"content":"Reverse and Append/3 Predicates","children":[{"type":"heading","depth":3,"payload":{"lines":[569,570]},"content":"reverse/3 and append/3 are two commonly used user-defined list processing predicates."},{"type":"heading","depth":3,"payload":{"lines":[570,571]},"content":"Reverse/3 reverses the order of elements in a list when passed to it, while append/3 combines two lists into one."},{"type":"heading","depth":3,"payload":{"lines":[571,572]},"content":"When using either predicate to construct a list, be mindful of which direction the list is being built (up or down) as this will effect the order of elements."},{"type":"heading","depth":3,"payload":{"lines":[572,573]},"content":"Append/3 is also a two-way predicate, meaning it can be used to deconstruct a list into two smaller ones."},{"type":"heading","depth":3,"payload":{"lines":[573,574]},"content":"Both predicates can be used backwards to make two lists out of one, which can be useful for stripping lists apart and checking their contents."}]},{"type":"heading","depth":2,"payload":{"lines":[575,576]},"content":"Using Recursion to Process Lists","children":[{"type":"heading","depth":3,"payload":{"lines":[576,577]},"content":"Use base and recursive cases to process lists with recursion."},{"type":"heading","depth":3,"payload":{"lines":[577,578]},"content":"Use focused recursion to prevent infinite loops."},{"type":"heading","depth":3,"payload":{"lines":[578,579]},"content":"Use recursion to implement member/2, listlength/3, append/3 and reverse/3."},{"type":"heading","depth":3,"payload":{"lines":[579,580]},"content":"Use an accumulator to build result during recursion."},{"type":"heading","depth":3,"payload":{"lines":[580,581]},"content":"Use the Prolog tracer to debug recursive predicates."},{"type":"heading","depth":3,"payload":{"lines":[581,582]},"content":"Use recursively finding a result, then revising it at each level."}]}]},{"type":"heading","depth":1,"payload":{"lines":[589,590]},"content":"Lecture 12: Exercises on Lists Processing","children":[{"type":"heading","depth":2,"payload":{"lines":[591,592]},"content":"Exercises on Lists Processing","children":[{"type":"heading","depth":3,"payload":{"lines":[592,593]},"content":"Write a predicate write_list/1 to write the elements of a list: write_list([]). write_list([X|Xs]):- tab(2), write(X), write_list(Xs)."},{"type":"heading","depth":3,"payload":{"lines":[593,594]},"content":"Write a predicate write_every_second/1 to print every other element in a list, beginning at the second element: write_every_second ([]). write_every_second([X]). write_every_second([X, Y|T]): write(Y), write_every_second(T)."},{"type":"heading","depth":3,"payload":{"lines":[594,595]},"content":"Write a predicate deconsonant/1 to print any element of a list that isn't a consonant: deconsonant([]). deconsonant([AB]):- vowel(A), write(A), deconsonant(B). deconsonant([AB]): deconsonant(B). vowel(a). vowel(e). vowel(i). vowel(o). vowel(u)."},{"type":"heading","depth":3,"payload":{"lines":[595,596]},"content":"Write a predicate list_sum/2 to sum elements of a list: list sum([],0). list_sum([X|Xs],Sum):- list_sum(Xs,Sum1), Sum is X + Sum1."},{"type":"heading","depth":3,"payload":{"lines":[596,597]},"content":"Write a predicate list_sum/3 to sum the corresponding elements of two lists: list_sum([],[],[]). list_sum([X|Xs],[Y|Ys],[Z|Zs]):- Z is X + Y, list_sum(Xs,Ys,Zs)."}]}]},{"type":"heading","depth":1,"payload":{"lines":[612,613]},"content":"Lecture 13: Controlling Backtracking in Prolog","children":[{"type":"heading","depth":2,"payload":{"lines":[615,616]},"content":"Controlling Backtracking in Prolog","children":[{"type":"heading","depth":3,"payload":{"lines":[616,617]},"content":"Goal Processing in Prolog: Find first clause head that matches (unifies) G and bind all variables accordingly; call subgoals in body of G in order; if all succeed, G succeeds (and exits); if no next clause, fail the goal G."},{"type":"heading","depth":3,"payload":{"lines":[617,618]},"content":"Redo-ing a Goal: Discard bindings from previous success; try clauses for this goal not so far tried; if none, fail the goal."},{"type":"heading","depth":3,"payload":{"lines":[618,619]},"content":"Example: State of Pollution Alert: Rule 1: If X &lt; 3 then Y = normal; Rule 2: If 3 ≤ X and X &lt; 6 then Y = alert1; Rule 3: If 6 ≤ X then Y = alert2."},{"type":"heading","depth":3,"payload":{"lines":[619,620]},"content":"Experiment 1 Trace: Call f (2, 10068); if 2&lt;3 then Exit f(2, normal); else try 3=&lt;2, if fail then Redo f(2, 10068) and try 6=&lt;2, if fail then Exit f (2, false. 10068)."}]},{"type":"heading","depth":2,"payload":{"lines":[621,622]},"content":"Using Cuts to Make Prolog Code More Efficient","children":[{"type":"heading","depth":3,"payload":{"lines":[622,623]},"content":"Using cut (!) at the start of the body commits to the clause as soon as head unification succeeds."},{"type":"heading","depth":3,"payload":{"lines":[623,624]},"content":"Placing a cut somewhere within the body (not at the start of the body) states that we cannot commit to the clause until certain sub-goals have been satisfied."},{"type":"heading","depth":3,"payload":{"lines":[624,625]},"content":"To make code more efficient, we can use Green Cuts - where the cut does not alter the logical behaviour of the program, only the procedural behaviour, specifying which goals get checked when."},{"type":"heading","depth":3,"payload":{"lines":[625,626]},"content":"When using Green Cuts, we must ensure that the clauses are mutually exclusive."},{"type":"heading","depth":3,"payload":{"lines":[626,627]},"content":"Redundant tests can be removed to make code more efficient."}]},{"type":"heading","depth":2,"payload":{"lines":[628,629]},"content":"The Use of Cuts in Prolog","children":[{"type":"heading","depth":3,"payload":{"lines":[629,630]},"content":"Cuts are a useful feature of Prolog which can be used to improve the efficiency of a program."},{"type":"heading","depth":3,"payload":{"lines":[630,631]},"content":"The two types of cuts are red and green cuts. Red cuts change the logical behaviour of a predicate, while green cuts are used to control backtracking."},{"type":"heading","depth":3,"payload":{"lines":[631,632]},"content":"Red cuts should be used with caution, as they can make programs difficult to read and depend on the specific order of clauses."},{"type":"heading","depth":3,"payload":{"lines":[632,633]},"content":"When using cuts, tests should not be omitted. To ensure a logic-friendly cut, test1, test2, etc. should be included."}]},{"type":"heading","depth":2,"payload":{"lines":[634,635]},"content":"Controlling Backtracking in Prolog","children":[{"type":"heading","depth":3,"payload":{"lines":[635,636]},"content":"Prolog has various ways of controlling backtracking such as the use of the cut (!) and fail predicates."},{"type":"heading","depth":3,"payload":{"lines":[636,637]},"content":"The cut (!) can be used to prevent backtracking to clauses that have already been tried, making code more efficient and easier to follow."},{"type":"heading","depth":3,"payload":{"lines":[637,638]},"content":"The fail predicate can be combined with a cut to specify when a goal should fail."},{"type":"heading","depth":3,"payload":{"lines":[638,639]},"content":"Negation as Failure is a technique used to represent facts that should be false, instead of those that should be true."},{"type":"heading","depth":3,"payload":{"lines":[639,640]},"content":"Closed World Assumption is an assumption that the world is defined in its entirety, and no true statements are missing from the representation."}]},{"type":"heading","depth":2,"payload":{"lines":[641,642]},"content":"Evaluating Cuts in Predicate Logic","children":[{"type":"heading","depth":3,"payload":{"lines":[642,643]},"content":"Green cuts: cuts that do not change the predicate logic, and are therefore good."},{"type":"heading","depth":3,"payload":{"lines":[643,644]},"content":"Red cuts: cuts that change the predicate logic and are therefore bad."},{"type":"heading","depth":3,"payload":{"lines":[644,645]},"content":"Cut-Fail: when it is easier to prove something is false than true."}]}]},{"type":"heading","depth":1,"payload":{"lines":[663,664]},"content":"Lecture 14: Abstract Data Type (ADT) in Prolog","children":[{"type":"heading","depth":2,"payload":{"lines":[666,667]},"content":"Stack and Tree Data Types in Prolog","children":[{"type":"heading","depth":3,"payload":{"lines":[667,668]},"content":"Stack is a Last In First Out (LIFO) data structure used to hold papers, books, coins, cards, etc."},{"type":"heading","depth":3,"payload":{"lines":[668,669]},"content":"Stack operations include create new stack, push, pop, peek, and empty."},{"type":"heading","depth":3,"payload":{"lines":[669,670]},"content":"Examples of stack applications include syntax checker, expression evaluation, search trees and backtracking algorithms."},{"type":"heading","depth":3,"payload":{"lines":[670,671]},"content":"Queue data type is a First In First Out (FIFO) data structure used for tasks such as printing, loading and unloading."},{"type":"heading","depth":3,"payload":{"lines":[671,672]},"content":"Tree data type is an abstract data type with operations to create a new tree, insert an element in a tree, and traverse a tree."},{"type":"heading","depth":3,"payload":{"lines":[672,673]},"content":"Applications of tree data type include search trees, backtracking algorithms, and balanced parenthesis operator parsing."}]},{"type":"heading","depth":2,"payload":{"lines":[674,675]},"content":"Evaluating Expressions Using Stacks","children":[{"type":"heading","depth":3,"payload":{"lines":[675,676]},"content":"To evaluate an expression, such as 1+2*3+4, you need two stacks: one for operands (numbers), the other for operators: going left to right, if you see a number, push it on the number stack; if you see an operator, while the top of the operator stack holds an operator of equal or higher precedence, pop the old operator, pop the top two values from the number stack and apply the old operator to them, push the result on the number stack, and push the new operator on the operator stack."},{"type":"heading","depth":3,"payload":{"lines":[676,677]},"content":"To detect unbalanced parenthesis, pop the stack and check whether you popped the corresponding (, [, or {. When you reach the end, check that the stack is empty."},{"type":"heading","depth":3,"payload":{"lines":[677,678]},"content":"An example of performing calculations is given: for 1+2*3+4, push 1 on the number stack, push + on the operator stack, push 2 on the number stack, push * on the operator stack, push 3 on the number stack, push + on the operator stack, push 4 on the number stack, and pop 4, 6 and +, compute 6+4=10, push 10; pop 10, 1, and +, compute 1+10=11, push 11. The answer (at the top of the stack) is 11."}]},{"type":"heading","depth":2,"payload":{"lines":[679,680]},"content":"Understanding Trees and Queues","children":[{"type":"heading","depth":3,"payload":{"lines":[680,681]},"content":"Trees and queues are important data structures used in computer science."},{"type":"heading","depth":3,"payload":{"lines":[681,682]},"content":"A queue is a data structure that follows a First In, First Out (FIFO) order, meaning the first element added to the list must be the first element to come out of the list."},{"type":"heading","depth":3,"payload":{"lines":[682,683]},"content":"When we add an element to a queue, we enqueue it, and when we remove an element, we dequeue it."},{"type":"heading","depth":3,"payload":{"lines":[683,684]},"content":"We can also check the element at the head of the queue and test if the queue is empty."},{"type":"heading","depth":3,"payload":{"lines":[684,685]},"content":"Trees are data structures that consist of nodes connected by directed edges."},{"type":"heading","depth":3,"payload":{"lines":[685,686]},"content":"Each node in a tree has a value and may have children and parents."},{"type":"heading","depth":3,"payload":{"lines":[686,687]},"content":"Trees can be used for tasks such as simulations, file servers, and message passing."},{"type":"heading","depth":3,"payload":{"lines":[687,688]},"content":"Trees can also be used for graph algorithms such as breadth-first search."}]},{"type":"heading","depth":2,"payload":{"lines":[689,690]},"content":"Traversing a Tree","children":[{"type":"heading","depth":3,"payload":{"lines":[690,691]},"content":"Pre-order traversal visits the node, then its left child, then its right child."},{"type":"heading","depth":3,"payload":{"lines":[691,692]},"content":"In-order traversal visits the left child, then the node, then the right child."},{"type":"heading","depth":3,"payload":{"lines":[692,693]},"content":"Post-order traversal visits the left child, then the right child, then the node."},{"type":"heading","depth":3,"payload":{"lines":[693,694]},"content":"For the given example tree, pre-order traversal would result in the list: [1, 15, 25, 13, 14, 35]."},{"type":"heading","depth":3,"payload":{"lines":[694,695]},"content":"In-order traversal would result in the list: [25, 15, 1, 14, 35, 13]."},{"type":"heading","depth":3,"payload":{"lines":[695,696]},"content":"Post-order traversal would result in the list: [25, 15, 35, 14, 13, 1]."}]},{"type":"heading","depth":2,"payload":{"lines":[697,698]},"content":"Exploring Tree Traversal and Applications","children":[{"type":"heading","depth":3,"payload":{"lines":[698,699]},"content":"Traverse a Tree in-order: visit the left child, then visit the node, then visit the right child."},{"type":"heading","depth":3,"payload":{"lines":[699,700]},"content":"Traverse a Tree post-order: visit the left child, then visit the right child, then visit the node."},{"type":"heading","depth":3,"payload":{"lines":[700,701]},"content":"Tree Applications: Parse Tree, Evaluation of expression, Trie trees, Decision Tree."}]}]},{"type":"heading","depth":1,"payload":{"lines":[710,711]},"content":"Lecture 15: Blind search techniques and their implementation","children":[{"type":"heading","depth":2,"payload":{"lines":[714,715]},"content":"Search Techniques","children":[{"type":"heading","depth":3,"payload":{"lines":[715,716]},"content":"Start State: Many problems in AI take the form of state-space search, where a solution is a sequence of actions (path) leading from the initial state to a goal state."},{"type":"heading","depth":3,"payload":{"lines":[716,717]},"content":"State Space: The state-space is the configuration of the possible states and how they connect to each other."},{"type":"heading","depth":3,"payload":{"lines":[717,718]},"content":"Problem Formulation: Set of possible states, set of possible operations that change the state, specification of a starting (initial) state(s) and a goal (final) state(s)."},{"type":"heading","depth":3,"payload":{"lines":[718,719]},"content":"Graph: Nodes correspond to problem situations (states) and arcs correspond to legal moves."},{"type":"heading","depth":3,"payload":{"lines":[719,720]},"content":"Examples: 8-puzzles, blocks world, chess."}]},{"type":"heading","depth":2,"payload":{"lines":[721,722]},"content":"Search Trees and Graphs","children":[{"type":"heading","depth":3,"payload":{"lines":[722,723]},"content":"Search Trees provide a convenient description of the search space, they are not a data structure stored in memory."},{"type":"heading","depth":3,"payload":{"lines":[723,724]},"content":"Each node in a search tree represents one state."},{"type":"heading","depth":3,"payload":{"lines":[724,725]},"content":"The path from a parent node to a child node represents an operation."},{"type":"heading","depth":3,"payload":{"lines":[725,726]},"content":"There are a number of strategies for traversing a search tree."},{"type":"heading","depth":3,"payload":{"lines":[726,727]},"content":"An example problem: Searching a graph involves a set of nodes, each with a set of links connecting them."},{"type":"heading","depth":3,"payload":{"lines":[727,728]},"content":"The goal is to traverse the graph to find a path from one node to another."},{"type":"heading","depth":3,"payload":{"lines":[728,729]},"content":"Each link represents an operation which can be used to traverse the graph."}]},{"type":"heading","depth":2,"payload":{"lines":[730,731]},"content":"Finding Optimal Solutions in State-Space Search","children":[{"type":"heading","depth":3,"payload":{"lines":[731,732]},"content":"State-space search is a way of finding optimal solutions in a state-space."},{"type":"heading","depth":3,"payload":{"lines":[732,733]},"content":"An abstract representation of a state-space is a downwards growing tree, with connected nodes representing states in the domain and the branching factor depicting the number of new states accessible from any state."},{"type":"heading","depth":3,"payload":{"lines":[733,734]},"content":"Depth of a node represents the number of moves from the initial state."},{"type":"heading","depth":3,"payload":{"lines":[734,735]},"content":"An example of state-space search is finding the shortest path between two towns."},{"type":"heading","depth":3,"payload":{"lines":[735,736]},"content":"For a game such as chess, 'optimal' could refer to the best move we can make, by looking ahead to see the effects of possible moves."}]}]},{"type":"heading","depth":1,"payload":{"lines":[754,755]},"content":"Lecture 16: Blind search techniques and their implementation","children":[{"type":"heading","depth":2,"payload":{"lines":[756,757]},"content":"Problem and Solutions","children":[{"type":"heading","depth":3,"payload":{"lines":[757,758]},"content":"problemis defined by four items:","children":[{"type":"heading","depth":4,"payload":{"lines":[758,759]},"content":"Initial state: The state agent starts in."},{"type":"heading","depth":4,"payload":{"lines":[759,760]},"content":"Successor function: For each action, the resulting state and its available action."},{"type":"heading","depth":4,"payload":{"lines":[760,761]},"content":"Goal test: Whether the given state is a goal state."},{"type":"heading","depth":4,"payload":{"lines":[761,762]},"content":"Path cost: Assigns numeric cost to each path (step cost for taking action a from state x to y - denoted by c(x,a,y))."}]},{"type":"heading","depth":3,"payload":{"lines":[762,763]},"content":"A solution is a sequence of actions leading from the initial state to a goal state"},{"type":"heading","depth":3,"payload":{"lines":[763,764]},"content":"Vacuum world: Single-state, start in #5 - solution?"},{"type":"heading","depth":3,"payload":{"lines":[764,765]},"content":"8-puzzle: Integer locations of tiles (ignore intermediate positions), actions - Left, Right, Suck, NoOp, goal test - no dirt, path cost - 1 per action (0 for NoOp)."}]},{"type":"heading","depth":2,"payload":{"lines":[766,767]},"content":"Tree Search Algorithms","children":[{"type":"heading","depth":3,"payload":{"lines":[767,768]},"content":"Tree search algorithms are used for an offline, simulated exploration of a state space by generating successors of already-explored states."},{"type":"heading","depth":3,"payload":{"lines":[768,769]},"content":"They involve initializing the search tree using the initial state of the problem, choosing a leaf node for expansion according to a strategy, checking if the node contains a goal state, expanding the node and adding the resulting nodes to the search tree."},{"type":"heading","depth":3,"payload":{"lines":[769,770]},"content":"Search strategies are evaluated along four dimensions: completeness, time complexity, space complexity and optimality."},{"type":"heading","depth":3,"payload":{"lines":[770,771]},"content":"Examples of tree search algorithms include the 8-puzzle, Romania and Arad."}]},{"type":"heading","depth":2,"payload":{"lines":[772,773]},"content":"Uninformed Search Strategies","children":[{"type":"heading","depth":3,"payload":{"lines":[773,774]},"content":"Uninformed search strategies, also known as &quot;blind search&quot;, use only the information available in the problem definition, regardless of whether it is efficient or not."},{"type":"heading","depth":3,"payload":{"lines":[774,775]},"content":"Breadth-first search checks every node at one level of the space before moving onto the next level."},{"type":"heading","depth":3,"payload":{"lines":[775,776]},"content":"Depth-first search always follows the left-most branch of the search tree first until it either finds the goal state or hits a dead-end."},{"type":"heading","depth":3,"payload":{"lines":[776,777]},"content":"Time complexity of Breadth-first search is O(bd+1) while space complexity is O(bd+1) (keeps every node in memory)."},{"type":"heading","depth":3,"payload":{"lines":[777,778]},"content":"Depth-first search is optimal if cost = 1 per step, but not optimal in general."},{"type":"heading","depth":3,"payload":{"lines":[778,779]},"content":"Space is the big problem; it can easily generate nodes at 100MB/sec so 24hrs = 8640GB."}]},{"type":"heading","depth":2,"payload":{"lines":[780,781]},"content":"Depth-First Search","children":[{"type":"heading","depth":3,"payload":{"lines":[781,782]},"content":"Depth-first search always follows the left-most branch of the search tree first; following it down until it either finds the goal state or hits a dead-end."},{"type":"heading","depth":3,"payload":{"lines":[782,783]},"content":"It will then backtrack to find another branch to follow."},{"type":"heading","depth":3,"payload":{"lines":[783,784]},"content":"It can suffer if there are loops in the state space, as the search can go on indefinitely down one path."}]},{"type":"heading","depth":2,"payload":{"lines":[785,786]},"content":"Properties of Depth-first Search","children":[{"type":"heading","depth":3,"payload":{"lines":[786,787]},"content":"No: fails in infinite-depth spaces and spaces with loops; modify to avoid repeated states along path"},{"type":"heading","depth":3,"payload":{"lines":[787,788]},"content":"Complete: complete in finite spaces"},{"type":"heading","depth":3,"payload":{"lines":[788,789]},"content":"Time: O(bm): terrible if m is much larger than d"},{"type":"heading","depth":3,"payload":{"lines":[789,790]},"content":"Space: O(bm), i.e., linear space"},{"type":"heading","depth":3,"payload":{"lines":[790,791]},"content":"Optimal: No"},{"type":"heading","depth":3,"payload":{"lines":[791,792]},"content":"Iterative Deepening: vary depth of search, increasing depth every time all nodes at a particular depth are exhausted"}]},{"type":"heading","depth":2,"payload":{"lines":[793,794]},"content":"A Comprehensive Analysis of Iterative Deepening Search","children":[{"type":"heading","depth":3,"payload":{"lines":[794,795]},"content":"Iterative Deepening Search (IDS) is a search algorithm with a depth limit set to {0, 1, 2, 3, 4}."},{"type":"heading","depth":3,"payload":{"lines":[795,796]},"content":"IDS is complete, meaning that it will find a solution if one exists."},{"type":"heading","depth":3,"payload":{"lines":[796,797]},"content":"Time complexity of IDS is O(ba), where b is the branching factor and a is the depth of the shallowest goal node."},{"type":"heading","depth":3,"payload":{"lines":[797,798]},"content":"Space complexity of IDS is O(bd), where b is the branching factor and d is the depth limit of the search."},{"type":"heading","depth":3,"payload":{"lines":[798,799]},"content":"IDS is optimal if step cost is 1."},{"type":"heading","depth":3,"payload":{"lines":[799,800]},"content":"Numerically, IDS has better performance than BFS when b=10 and d=5."},{"type":"heading","depth":3,"payload":{"lines":[800,801]},"content":"IDS is simple to implement, reaches a solution quickly, and can be modified to explore uniform-cost tree."}]},{"type":"heading","depth":2,"payload":{"lines":[802,803]},"content":"Agenda-based Search","children":[{"type":"heading","depth":3,"payload":{"lines":[803,804]},"content":"Agenda-based search is used to implement both depth-first and breadth-first search, with breadth-first search only able to be implemented with an agenda."},{"type":"heading","depth":3,"payload":{"lines":[804,805]},"content":"The agenda holds a list of states in the state space, with the initial state being the first one."},{"type":"heading","depth":3,"payload":{"lines":[805,806]},"content":"In depth-first search, the new nodes are inserted at the front of the agenda, using a Last-In-First-Out approach."},{"type":"heading","depth":3,"payload":{"lines":[806,807]},"content":"In breadth-first search, the new nodes are inserted at the end of the agenda, using a First-In-First-Out approach."},{"type":"heading","depth":3,"payload":{"lines":[807,808]},"content":"If the first state of the agenda is the one we're looking for, the search is complete."},{"type":"heading","depth":3,"payload":{"lines":[808,809]},"content":"Otherwise, the state is expanded and the new nodes generated are added to the agenda to be dealt with in turn."}]},{"type":"heading","depth":2,"payload":{"lines":[810,811]},"content":"Uninformed Search Strategies","children":[{"type":"heading","depth":3,"payload":{"lines":[811,812]},"content":"Blind (uninformed) search strategies, such as depth-first and breadth-first, can be used to find optimal paths through problem spaces."},{"type":"heading","depth":3,"payload":{"lines":[812,813]},"content":"Prolog's unification strategy allows for a simple implementation of depth-first search, while breadth-first searches always finds the shortest path to the goal state."},{"type":"heading","depth":3,"payload":{"lines":[813,814]},"content":"Both search strategies can be implemented with an agenda, with depth-first adding nodes to the front and breadth-first adding nodes to the end."},{"type":"heading","depth":3,"payload":{"lines":[814,815]},"content":"Uninformed search strategies are impractical for non-trivial problems as they do not consider past cost from the current state to the goal."}]}]},{"type":"heading","depth":1,"payload":{"lines":[834,835]},"content":"Lecture 17: Informed Search Strategies","children":[{"type":"heading","depth":2,"payload":{"lines":[838,839]},"content":"Informed Search Strategies","children":[{"type":"heading","depth":3,"payload":{"lines":[839,840]},"content":"Informed search strategies use knowledge about the domain to search through the state-space in a more directed manner, which can find a solution more quickly or find a better solution than blind search."},{"type":"heading","depth":3,"payload":{"lines":[840,841]},"content":"A heuristic is an informed guess of the next step to be taken in solving a problem and can lead to a sub-optimal solution or fail to find any solution."},{"type":"heading","depth":3,"payload":{"lines":[841,842]},"content":"Best-first search is a modified agenda-based search that sorts the agenda according to some measure of how promising a state is."},{"type":"heading","depth":3,"payload":{"lines":[842,843]},"content":"Uniform-cost search is a special case of best-first search where the agenda is sorted by the cost-so-far, which will always find an optimal solution even if the steps between states have different costs."}]},{"type":"heading","depth":2,"payload":{"lines":[844,845]},"content":"Heuristic Evaluation Functions for Route-Finding Problem","children":[{"type":"heading","depth":3,"payload":{"lines":[845,846]},"content":"Heuristics are criteria, methods, or principles used to decide which among several alternative courses of action promises to be the most effective in order to achieve some goals."},{"type":"heading","depth":3,"payload":{"lines":[846,847]},"content":"Heuristic evaluation functions, h(n), are estimated costs of the cheapest path from the state at node n, to a goal state."},{"type":"heading","depth":3,"payload":{"lines":[847,848]},"content":"One example of a heuristic evaluation function is h(tile), which counts the tiles out of place in each state when it is compared with the goal."},{"type":"heading","depth":3,"payload":{"lines":[848,849]},"content":"Another example of a heuristic evaluation function is h(tile) Manhattan Distance, which sums all the distances by which the tiles are out of place, one for each square a tile must be moved to reach its position in the goal state."},{"type":"heading","depth":3,"payload":{"lines":[849,850]},"content":"Straight-line distance can also be used as a heuristic evaluation function, which is the distance between two locations on a map without knowing how they are linked by roads."},{"type":"heading","depth":3,"payload":{"lines":[850,851]},"content":"Greedy search can be used to expand node with the smallest (closest) cost to reach the goal, but is not optimal and can wander into dead-ends."}]},{"type":"heading","depth":2,"payload":{"lines":[852,853]},"content":"Greedy Search Example","children":[{"type":"heading","depth":3,"payload":{"lines":[853,854]},"content":"Arad is the starting point for a holiday in Romania and the flight leaves tomorrow from Bucharest."},{"type":"heading","depth":3,"payload":{"lines":[854,855]},"content":"Problem formulation: states are various cities and actions are driving between cities."},{"type":"heading","depth":3,"payload":{"lines":[855,856]},"content":"Greedy search example shows a sequence of cities from Arad to Bucharest, with step costs in km."},{"type":"heading","depth":3,"payload":{"lines":[856,857]},"content":"Straight line distance to Bucharest from Arad is 366 km."},{"type":"heading","depth":3,"payload":{"lines":[857,858]},"content":"Greedy search example shows the steps taken from Arad via Oradea, Zerind, Timisoara, Dobreta, Lugoj, Sibiu, Fagaras, Rimnicu Vilcea, Pitesti, Craiova, Neamt, Giurgiu, lasi, Urziceni, Vaslui and Hirsova to Eforie and then to Bucharest."},{"type":"heading","depth":3,"payload":{"lines":[858,859]},"content":"The straight line distance from Fagaras to Bucharest is 176 km, from Rimnicu Vilcea 193 km, and from Sibiu to Bucharest is 253 km."}]},{"type":"heading","depth":2,"payload":{"lines":[860,861]},"content":"A* Algorithm for Romania","children":[{"type":"heading","depth":3,"payload":{"lines":[861,862]},"content":"A* is an algorithm combining cost-so-far and heuristic functions to find the optimal path between the initial state and goal state."},{"type":"heading","depth":3,"payload":{"lines":[862,863]},"content":"It's measured by the sum of the cost-so-far and the estimated cost from the state to the nearest goal state (f(n) = g(n) + h (n))."},{"type":"heading","depth":3,"payload":{"lines":[863,864]},"content":"Step costs in km are given for Romania, including Arad, Sibiu, Oradea, Zerind, Timisoara, Dobreta, Lugoj, Fagaras, Mehadia, Rimnicu Vilcea, Pitesti, Craiova, Neamt, Giurgiu, Bucharest, lasi, Urziceni, Vaslui, and Hirsova."},{"type":"heading","depth":3,"payload":{"lines":[864,865]},"content":"Straight line distances from each of these cities to Bucharest are also given."},{"type":"heading","depth":3,"payload":{"lines":[865,866]},"content":"Example of A* search from Arad to Bucharest is provided (Total cost = 366+75+140=581)."}]},{"type":"heading","depth":2,"payload":{"lines":[867,868]},"content":"A* Search and Admissibility","children":[{"type":"heading","depth":3,"payload":{"lines":[868,869]},"content":"A* search example from Sibiu to Oradea involves the calculation of the cost from Arad to Fagaras (646-280+366) and from Fagaras to Oradea (415-239+176)."},{"type":"heading","depth":3,"payload":{"lines":[869,870]},"content":"The straight line distance from Arad to Bucharest is 366, from Craiova to Bucharest is 418-418+0, from Sibiu to Bucharest is 553-300+253, and from Rimnicu Vilcea to Bucharest is 526-366+160."},{"type":"heading","depth":3,"payload":{"lines":[870,871]},"content":"Arad to Pitesti has a cost of 111, to Timisoara is 75, to Dobreta is 151, to Lugoj is 70, and to Mehadia is 75."},{"type":"heading","depth":3,"payload":{"lines":[871,872]},"content":"Timisoara to Sibiu has a cost of 447-118+329, and Rimnicu Vilcea to Sibiu is 97."},{"type":"heading","depth":3,"payload":{"lines":[872,873]},"content":"Fagaras to Pitesti is 120, to Craiova is 138, to Neamt is 85, to Giurgiu is 87, to Bucharest is 90, to lasi is 92, to Urziceni is 142, to Vaslui is 98, and to Zerind is 449-75+374."},{"type":"heading","depth":3,"payload":{"lines":[873,874]},"content":"Eforie to Bucharest has a straight line distance of 86."}]},{"type":"heading","depth":2,"payload":{"lines":[875,876]},"content":"Blind Search vs Heuristic Search","children":[{"type":"heading","depth":3,"payload":{"lines":[876,877]},"content":"Blind Search algorithms (e.g. Depth-First, Breadth-First and IDS) do not take into account knowledge of the problem space to find a solution."},{"type":"heading","depth":3,"payload":{"lines":[877,878]},"content":"Informed (Heuristic) Search makes use of guesses, rules of thumb, etc. to aid the search. It involves making an estimate of how far away the solution is after each possible next move and choosing the move with the lowest estimate."},{"type":"heading","depth":3,"payload":{"lines":[878,879]},"content":"Best-first search orders the agenda based on some measure of how 'good' each state is. Uniform-cost search uses the cost of getting to the current state from the initial state as the measure, while greedy search uses the estimated cost of reaching the goal from the current state."},{"type":"heading","depth":3,"payload":{"lines":[879,880]},"content":"A* search is a combination of uniform-cost search and greedy search, where the agenda is sorted according to the function f(n) = g(n) + h(n). For this to work, the function h(n) must never overestimate the actual cost of getting to the goal state, which is known as admissibility."},{"type":"heading","depth":3,"payload":{"lines":[880,881]},"content":"Informedness is the measure of how much a search strategy searches less of the state-space in order to find a goal state. If a heuristic h1 is less than or equal to a heuristic h2 for all states n in the state-space, then h2 is said to be more informed than h1."}]}]},{"type":"heading","depth":1,"payload":{"lines":[891,892]},"content":"Lecture 18: Search problems","children":[{"type":"heading","depth":2,"payload":{"lines":[894,895]},"content":"Which node will be expandednext by each of the following search methods?","children":[{"type":"heading","depth":3,"payload":{"lines":[895,896]},"content":"Breadth-first search: C"},{"type":"heading","depth":3,"payload":{"lines":[896,897]},"content":"Depth-first search: E"},{"type":"heading","depth":3,"payload":{"lines":[897,898]},"content":"Greedy-search (cost to the goal): C"},{"type":"heading","depth":3,"payload":{"lines":[898,899]},"content":"Uniform-cost search (cost so far): D"},{"type":"heading","depth":3,"payload":{"lines":[899,900]},"content":"A* search: G"},{"type":"heading","depth":3,"payload":{"lines":[900,901]},"content":"Brute-force (blind) searches: H, M, N, D, 0, 3"}]},{"type":"heading","depth":2,"payload":{"lines":[902,903]},"content":"Maze Problem Analysis","children":[{"type":"heading","depth":3,"payload":{"lines":[903,904]},"content":"Consider the following maze with successors, boundaries and barriers of a cell, and each type of move having cost 1: SHFKPCQARBTDG."},{"type":"heading","depth":3,"payload":{"lines":[904,905]},"content":"The problem is to find a path from cell S to cell G. Breadth First Search (without duplicates) visits cells in the order: SHFKPCQARBTDG."},{"type":"heading","depth":3,"payload":{"lines":[905,906]},"content":"For parts (A-C), the order of nodes expanded (plus the goal node if it is found) by each of the search methods are as follows:"},{"type":"heading","depth":3,"payload":{"lines":[906,907]},"content":"A. Depth First Search expands nodes in the order SHKCA BD MG."},{"type":"heading","depth":3,"payload":{"lines":[907,908]},"content":"B. Greedy Search expands nodes in the order SHKCA BD MG."},{"type":"heading","depth":3,"payload":{"lines":[908,909]},"content":"C. Algorithm A* Search expands nodes in the order SHKCA BD MG."}]}]},{"type":"heading","depth":1,"payload":{"lines":[920,921]},"content":"Lecture 19: Constraint Satisfaction Problems (CSP) Part 1","children":[{"type":"heading","depth":2,"payload":{"lines":[924,925]},"content":"Constraint Satisfaction Problems","children":[{"type":"heading","depth":3,"payload":{"lines":[925,926]},"content":"CSPs are a finite set of variables X₁, X₂, ..., X₂ n, with each variable having a nonempty domain of possible values DXI, Dx2 ... Dxn, and a finite set of constraints C₁, C₂, ..., Cm, that limits the values that variables can take."},{"type":"heading","depth":3,"payload":{"lines":[926,927]},"content":"A complete assignment is one where every variable has a value and a solution to a CSP is a complete assignment that satisfies all constraints, which may include maximising an objective function."},{"type":"heading","depth":3,"payload":{"lines":[927,928]},"content":"The constraint graph is a representation of CSPs with binary constraints, where each constraint relates two variables, while the nodes are variables and arcs are constraints."},{"type":"heading","depth":3,"payload":{"lines":[928,929]},"content":"There are varieties of CSPs, such as those with finite and infinite domains."}]},{"type":"heading","depth":2,"payload":{"lines":[930,931]},"content":"Solving Constraint Satisfaction Problems","children":[{"type":"heading","depth":3,"payload":{"lines":[931,932]},"content":"Constraint satisfaction problems (CSPs) involve assigning values to variables subject to certain constraints."},{"type":"heading","depth":3,"payload":{"lines":[932,933]},"content":"A CSP can be expressed as a standard search problem with an initial state, operators/successor function, goal test, and path cost."},{"type":"heading","depth":3,"payload":{"lines":[933,934]},"content":"For a CSP with n variables and a maximum of d possible values, the branching factor at each level is (n x d)."},{"type":"heading","depth":3,"payload":{"lines":[934,935]},"content":"A backtracking search can be used to solve CSPs, which only considers assignments to one variable at each node."}]},{"type":"heading","depth":2,"payload":{"lines":[936,937]},"content":"Understanding Backtracking Search","children":[{"type":"heading","depth":3,"payload":{"lines":[937,938]},"content":"Backtracking search is an uninformed algorithm for CSPs which uses a Depth-first search to choose values for variables one at a time, and backtracks when the variable has no legal values left to assign."},{"type":"heading","depth":3,"payload":{"lines":[938,939]},"content":"The BACKTRACKING-SEARCH() function returns a solution or failure, which is then acted upon by the RECURSIVE-BACKTRACKING() function."},{"type":"heading","depth":3,"payload":{"lines":[939,940]},"content":"The SELECT-UNASSIGNED-VARIABLE() function selects the next unassigned variable, based on the order given by the list Variables[csp]."},{"type":"heading","depth":3,"payload":{"lines":[940,941]},"content":"The ORDER-DOMAIN-VALUES() function orders the values of the selected variable, and the CONSTRAINTS[csp] function checks if the value is consistent with the assignment."},{"type":"heading","depth":3,"payload":{"lines":[941,942]},"content":"If the values are consistent, it adds the assignment to the result, and if the result is failure, it removes the assignment before returning failure."}]}]},{"type":"heading","depth":1,"payload":{"lines":[955,956]},"content":"Lecture 20: Constraint Satisfaction Problems (CSP) Part 2","children":[{"type":"heading","depth":2,"payload":{"lines":[961,962]},"content":"Improving Backtracking Search for Constraint Satisfaction Problems","children":[{"type":"heading","depth":3,"payload":{"lines":[962,963]},"content":"Variable selection (1): Minimum remaining values (MRV) heuristic rule to detect failure early if a variable has no legal values left."},{"type":"heading","depth":3,"payload":{"lines":[963,964]},"content":"Variable selection (2): Degree heuristic to reduce the branching factor on future choices."},{"type":"heading","depth":3,"payload":{"lines":[964,965]},"content":"Value selection: Order the values of a variable based on the number of constraints it has on remaining variables."},{"type":"heading","depth":3,"payload":{"lines":[965,966]},"content":"Benefits: Allows the colouring problem to be solved without any backtracking."}]},{"type":"heading","depth":2,"payload":{"lines":[967,968]},"content":"Heuristics and Constraints for the 4-Queens Problem","children":[{"type":"heading","depth":3,"payload":{"lines":[968,969]},"content":"Least constraining value heuristic: Select the value which leaves the maximum flexibility for subsequent variable assignments."},{"type":"heading","depth":3,"payload":{"lines":[969,970]},"content":"Forward checking: Keep track of remaining legal values for unassigned variables and terminate search when any variable has no legal values."},{"type":"heading","depth":3,"payload":{"lines":[970,971]},"content":"MRV (Minimum Remaining Values) heuristic: Automatically select the variable with the fewest legal values."},{"type":"heading","depth":3,"payload":{"lines":[971,972]},"content":"Example given of the 4-Queens Problem: Place 4 queens, one per column, so that they do not attack each other. Variables are X1-X4, with a domain of 1-4. Constraints are that none of the queens can attack each other."}]},{"type":"heading","depth":2,"payload":{"lines":[973,974]},"content":"Solving the 4-Queens Problem Using Heuristics","children":[{"type":"heading","depth":3,"payload":{"lines":[974,975]},"content":"Start by considering the constraint graph and noting the domain for each variable, as well as the two unary constraints and eight binary constraints."},{"type":"heading","depth":3,"payload":{"lines":[975,976]},"content":"Use the minimum value heuristic, degree heuristic, and forward checking to find a solution for this CSP."},{"type":"heading","depth":3,"payload":{"lines":[976,977]},"content":"Apply the minimum value heuristic by assigning variables with the lowest domain value."},{"type":"heading","depth":3,"payload":{"lines":[977,978]},"content":"Use the degree heuristic to assign variables with the highest number of constraints."},{"type":"heading","depth":3,"payload":{"lines":[978,979]},"content":"Forward checking eliminates any values from the domains that would result in a conflict with the assigned variables."},{"type":"heading","depth":3,"payload":{"lines":[979,980]},"content":"Continue to apply these heuristics until a solution is found."}]},{"type":"heading","depth":2,"payload":{"lines":[981,982]},"content":"Solving CSPs with Heuristics","children":[{"type":"heading","depth":3,"payload":{"lines":[982,983]},"content":"Utilize the constraint graph on the right, where the domain for each variable is [1,2,3,4]."},{"type":"heading","depth":3,"payload":{"lines":[983,984]},"content":"There are 2 unary constraints: &quot;a&quot; cannot take values 3 and 4, and &quot;b&quot; cannot take value 4."},{"type":"heading","depth":3,"payload":{"lines":[984,985]},"content":"There are 8 binary constraints, stating that connected variables cannot have the same value."},{"type":"heading","depth":3,"payload":{"lines":[985,986]},"content":"Use Minimum Value Heuristic (MVH), Degree Heuristic (DH), and Forward Checking (FC) to find a solution."},{"type":"heading","depth":3,"payload":{"lines":[986,987]},"content":"Start with MVH, by assigning a=1 (for example)."},{"type":"heading","depth":3,"payload":{"lines":[987,988]},"content":"Followed by FC+MVH to assign b=2."},{"type":"heading","depth":3,"payload":{"lines":[988,989]},"content":"Then, use FC+MVH+DH to assign c=3."},{"type":"heading","depth":3,"payload":{"lines":[989,990]},"content":"Afterward, assign d=4 with FC+MVH."},{"type":"heading","depth":3,"payload":{"lines":[990,991]},"content":"Lastly, assign e=1 with FC."}]},{"type":"heading","depth":2,"payload":{"lines":[992,993]},"content":"Solving CSPs with Heuristics and Forward Checking","children":[{"type":"heading","depth":3,"payload":{"lines":[993,994]},"content":"Arc-consistency (AC) is a systematic procedure for constraint propagation which makes each arc consistent."},{"type":"heading","depth":3,"payload":{"lines":[994,995]},"content":"Minimum value heuristic (MVH), degree heuristic (DH) and forward checking (FC) are effective heuristics for finding solutions to CSPs."},{"type":"heading","depth":3,"payload":{"lines":[995,996]},"content":"FC propagates information from assigned to unassigned variables, but doesn't provide early detection for all failures."},{"type":"heading","depth":3,"payload":{"lines":[996,997]},"content":"Constraint propagation techniques like CP and FC are in effect eliminating parts of the search space."},{"type":"heading","depth":3,"payload":{"lines":[997,998]},"content":"Solving CSPs with a combination of heuristics plus FC is more efficient than either approach alone."},{"type":"heading","depth":3,"payload":{"lines":[998,999]},"content":"Arc-consistency can be enforced by removing inconsistent values from a variable's neighbors."},{"type":"heading","depth":3,"payload":{"lines":[999,1000]},"content":"If a variable loses a value, its neighbors must be rechecked."}]},{"type":"heading","depth":2,"payload":{"lines":[1001,1002]},"content":"Arc Consistency Algorithm","children":[{"type":"heading","depth":3,"payload":{"lines":[1002,1003]},"content":"AC-3 is an arc consistency algorithm that uses a queue to keep track of arcs that need to be checked for inconsistency."},{"type":"heading","depth":3,"payload":{"lines":[1003,1004]},"content":"REMOVE-INCONSISTENT-VALUES is a function used to delete values from the domain of X₁ if any values need to be removed."},{"type":"heading","depth":3,"payload":{"lines":[1004,1005]},"content":"It can be used as a preprocessor before search starts, after each assignment, or repeatedly until no inconsistency remains."},{"type":"heading","depth":3,"payload":{"lines":[1005,1006]},"content":"If X loses a value, all incoming arcs to X must be rechecked as they can become inconsistent again."},{"type":"heading","depth":3,"payload":{"lines":[1006,1007]},"content":"CSPs are a special kind of problem defined by values of a fixed set of variables and constraints on variable values."},{"type":"heading","depth":3,"payload":{"lines":[1007,1008]},"content":"Backtracking, variable ordering, value selection heuristics, and forward checking help significantly."}]}]},{"type":"heading","depth":1,"payload":{"lines":[1025,1026]},"content":"Lecture 21:  Foundational concepts (in AI and ML)","children":[{"type":"heading","depth":2,"payload":{"lines":[1032,1033]},"content":"Knowledge Representation and Reasoning: Representing Uncertainty","children":[{"type":"heading","depth":3,"payload":{"lines":[1033,1034]},"content":"Probability theory allows for graded beliefs about uncertain situations."},{"type":"heading","depth":3,"payload":{"lines":[1034,1035]},"content":"Bayesian probability is a subjective measure of belief in an outcome."},{"type":"heading","depth":3,"payload":{"lines":[1035,1036]},"content":"Probabilities of propositions can change with new evidence."},{"type":"heading","depth":3,"payload":{"lines":[1036,1037]},"content":"Utility theory is used to represent and infer preferences."},{"type":"heading","depth":3,"payload":{"lines":[1037,1038]},"content":"Making decisions under uncertainty requires considering preferences for outcomes."}]},{"type":"heading","depth":2,"payload":{"lines":[1039,1040]},"content":"Decision Theory and Probability Basics","children":[{"type":"heading","depth":3,"payload":{"lines":[1040,1041]},"content":"Highutility is preferred in decision theory, which is a combination of utility theory and probability theory (degree of usefulness + degree of belief)."},{"type":"heading","depth":3,"payload":{"lines":[1041,1042]},"content":"Making decisions under uncertainty: Suppose there is a belief that the probability of getting to a destination on time is 0.04, 0.70, 0.95, and 0.9999 for the following actions: A25, A90, A120, and A1440, respectively. The utility (on time) is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>000</mn><mi>a</mi><mi>n</mi><mi>d</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo stretchy=\"false\">)</mo><mi>i</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">1,000 and the utility (not on time) is</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">000</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">im</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span></span></span></span>10,000."},{"type":"heading","depth":3,"payload":{"lines":[1042,1043]},"content":"Probability basics: Begin with a set of the sample space. The elements of the space can be all or a subset. A probability space or probability model is a sample space with an assignment of 0≤P(w)≤1 for every element in the space, with P(w)=1. If the sample space is {1,2,3,4,5,6}, P(1)=P(2)=P(3)=P(4)=P(5)=P(6)=1/6."},{"type":"heading","depth":3,"payload":{"lines":[1043,1044]},"content":"Random variables: For each event, introduce a random variable which takes on values from the associated set. For example, coin toss is {heads, tails}, roll a die is {1,2,3,4,5,6}, weather is {snow, sunny, rain, fog}, and measles is {true, false}."}]},{"type":"heading","depth":2,"payload":{"lines":[1045,1046]},"content":"Probability: Random Variables, Propositions, and Axioms","children":[{"type":"heading","depth":3,"payload":{"lines":[1046,1047]},"content":"Random variables are functions from sample points to some range, e.g., reals or Booleans."},{"type":"heading","depth":3,"payload":{"lines":[1047,1048]},"content":"Propositions are events (sets of sample points) where the proposition is true."},{"type":"heading","depth":3,"payload":{"lines":[1048,1049]},"content":"Axioms of probability state that 0 ≤ P (w) ≤ 1, P (true) = 1, P (false) = 0, and P (a V b) = P (a) + P (b) - P (a A b)."},{"type":"heading","depth":3,"payload":{"lines":[1049,1050]},"content":"Probability of a proposition can be calculated using discrete and continuous random variables."},{"type":"heading","depth":3,"payload":{"lines":[1050,1051]},"content":"Conditional probability is the probability of an event given another given event."}]},{"type":"heading","depth":2,"payload":{"lines":[1052,1053]},"content":"Probability Distribution and Conditional Probability","children":[{"type":"heading","depth":3,"payload":{"lines":[1053,1054]},"content":"Prior probability (1): The prior or unconditional probabilities of propositions, e.g. P(Cavity = true) = 0.1 and P(Weather = sunny) = 0.72."},{"type":"heading","depth":3,"payload":{"lines":[1054,1055]},"content":"Prior probability (2): Probability distribution gives values for all possible assignments, e.g. P(Weather = sunny) = 0.72, P(Weather = rain) = 0.1, P(Weather = cloudy) = 0.08, P(Weather = snow) = 0.1."},{"type":"heading","depth":3,"payload":{"lines":[1055,1056]},"content":"Prior probability (3): Abbreviation to denote the probability distribution, e.g. P(Weather) = 0.72, 0.1, 0.08, 0.1."},{"type":"heading","depth":3,"payload":{"lines":[1056,1057]},"content":"Joint probability distribution: A 4 × 2 matrix of values that denotes the probability of all combinations of the values Weather and Cavity."},{"type":"heading","depth":3,"payload":{"lines":[1057,1058]},"content":"The Joint Probability Distribution: Joint probabilities can be between any number of variables, e.g. P(A = true, B = true, C = true)."},{"type":"heading","depth":3,"payload":{"lines":[1058,1059]},"content":"Conditional probability: The posterior (after the fact) probability, often called the conditional probability, of an event is the probability of an event given some evidence, e.g. P (cavity/toothache) = 0.8."},{"type":"heading","depth":3,"payload":{"lines":[1059,1060]},"content":"Conditional probability (Notation): P(Cavity Toothache) = 2 X 2 vectors."},{"type":"heading","depth":3,"payload":{"lines":[1060,1061]},"content":"Conditional probability (Definition): P(alb) = #."}]},{"type":"heading","depth":2,"payload":{"lines":[1062,1063]},"content":"Conditional Probability","children":[{"type":"heading","depth":3,"payload":{"lines":[1063,1064]},"content":"Conditional probability is defined as the ratio of the blue area to the yellow area when P(alb) means, our universe has shrunk to the one in which b is true."},{"type":"heading","depth":3,"payload":{"lines":[1064,1065]},"content":"On Landsdowne street in Boston, the speed of 100 vehicles is measured and for each measurement, it is also noted whether the driver is a student."},{"type":"heading","depth":3,"payload":{"lines":[1065,1066]},"content":"The probability of a driver being a student and speeding is given by P(G|S) which is equal to 0.17."},{"type":"heading","depth":3,"payload":{"lines":[1066,1067]},"content":"Cavity and toothache events are characterized by a joint probability table with P(Cavity) being equal to 0.1 and P(Cavity v Toothache) being equal to 0.11."},{"type":"heading","depth":3,"payload":{"lines":[1067,1068]},"content":"The probability of having a cavity given that the person already has a toothache is equal to 0.8."},{"type":"heading","depth":3,"payload":{"lines":[1068,1069]},"content":"Inference by enumeration is the process of calculating the full joint distribution."}]},{"type":"heading","depth":2,"payload":{"lines":[1070,1071]},"content":"Inference by Enumeration and Independence","children":[{"type":"heading","depth":3,"payload":{"lines":[1071,1072]},"content":"Inference by enumeration start with the joint distribution and compute marginal probability of a proposition."},{"type":"heading","depth":3,"payload":{"lines":[1072,1073]},"content":"Independence states that knowing the outcome of one event will not tell us anything new about the outcome of another."},{"type":"heading","depth":3,"payload":{"lines":[1073,1074]},"content":"Conditional independence states that variables are conditionally independent given a third variable, meaning knowing the third variable provides all the information knowing the other two would give."}]},{"type":"heading","depth":2,"payload":{"lines":[1075,1076]},"content":"Understanding Bayes' Rule","children":[{"type":"heading","depth":3,"payload":{"lines":[1076,1077]},"content":"Bayes' Rule is used to calculate the probability of an event given the prior probability of another event."},{"type":"heading","depth":3,"payload":{"lines":[1077,1078]},"content":"It is useful for determining the probability of a diagnosis from a cause, e.g. Cavities as the cause of toothaches or Meningitis as the cause of a stiff neck."},{"type":"heading","depth":3,"payload":{"lines":[1078,1079]},"content":"Bayes' Rule states that P(a/b) = P(b|a)P(a) P (b) where P(a/b) is the conditional probability, P(b|a) is the probability of event b given event a, and P(a) is the prior probability of event a."},{"type":"heading","depth":3,"payload":{"lines":[1079,1080]},"content":"To use the rule, the doctor knows P(symptoms|disease) and wants to derive a diagnosis P(disease symptoms)."},{"type":"heading","depth":3,"payload":{"lines":[1080,1081]},"content":"As an example, let M be meningitis, S be stiff neck: P (m/s) = P(sm)P(m) = 0.8 × 0.0001 = 0.0008 P (s) 0.1."}]}]},{"type":"heading","depth":1,"payload":{"lines":[1086,1087]},"content":"Lecture 22:  Bayesian Networks","children":[{"type":"heading","depth":2,"payload":{"lines":[1089,1090]},"content":"Reasoning with Bayesian Networks","children":[{"type":"heading","depth":3,"payload":{"lines":[1090,1091]},"content":"Bayesian networks are a graphical notation and data structure for reasoning with uncertain domains."},{"type":"heading","depth":3,"payload":{"lines":[1091,1092]},"content":"They encode conditional independence assertions and simplify the associated probability distribution."},{"type":"heading","depth":3,"payload":{"lines":[1092,1093]},"content":"The root nodes (those with no ancestors) are assigned prior probability distributions."},{"type":"heading","depth":3,"payload":{"lines":[1093,1094]},"content":"Other nodes are assigned with the conditional probability distribution of the node given its parents."},{"type":"heading","depth":3,"payload":{"lines":[1094,1095]},"content":"The graph can have three types of connections: linear, converging, and diverging."},{"type":"heading","depth":3,"payload":{"lines":[1095,1096]},"content":"Markov dependence, independent causes, and explaining away effect can also be represented."}]},{"type":"heading","depth":2,"payload":{"lines":[1097,1098]},"content":"Alarm-Example: Three Types of Connections and Problem","children":[{"type":"heading","depth":3,"payload":{"lines":[1098,1099]},"content":"P(B|A)p(C|A)p(A): B and C are conditionally independent Given A."},{"type":"heading","depth":3,"payload":{"lines":[1099,1100]},"content":"P(A,B,C) = p(C|B) p(B|A) p(A): Three Types of Connections Linear A B C Markov dependence."},{"type":"heading","depth":3,"payload":{"lines":[1100,1101]},"content":"P(A,B,C) = p(C|A,B) p(A) p(B): Three Types of Connections Converging A C Independent Causes."},{"type":"heading","depth":3,"payload":{"lines":[1101,1102]},"content":"P(A,B,C) = p(B|A) p(C/A) p(A): Three Types of Connections Divergent B A Conditionally independent effects."},{"type":"heading","depth":3,"payload":{"lines":[1102,1103]},"content":"P(J|A) = 0.90, P(J|¬A) = 0.05, P(M|A) = 0.70 and P(M|¬A) = 0.01: Alarm-Example modeling their calling behavior using conditional probability."},{"type":"heading","depth":3,"payload":{"lines":[1103,1104]},"content":"P(A| B, E) = 0.95, P(A| B, -E) = 0.94, P(A|¬B, E) = 0.29 and P(A-B, -E) -0.001: Alarm-Example modeling the relationships between burglary, earthquake and alarm."},{"type":"heading","depth":3,"payload":{"lines":[1104,1105]},"content":"P(B) = 0.001 and P(E) = 0.002: Alarm-Example modeling independent variables."}]},{"type":"heading","depth":2,"payload":{"lines":[1106,1107]},"content":"Coding the Burglary Alarm Example","children":[{"type":"heading","depth":3,"payload":{"lines":[1107,1108]},"content":"Encode the burglary alarm example in the MS Bayesian Network Editor and Toolkit"},{"type":"heading","depth":3,"payload":{"lines":[1108,1109]},"content":"Check the query: Calculate P (Burglary JohnCalls = true, MarryCalls = true)"},{"type":"heading","depth":3,"payload":{"lines":[1109,1110]},"content":"Readings on Bayes' rule, syntax and semantics of Bayesian Networks, and a basic reasoning algorithm"},{"type":"heading","depth":3,"payload":{"lines":[1110,1111]},"content":"Business applications, probabilistic natural language processing, medical diagnosis, and advisory systems"},{"type":"heading","depth":3,"payload":{"lines":[1111,1112]},"content":"Lab exercise to download MS Bayesian Network Editor and Toolkit"}]}]}]},{"maxWidth":100})</script>
</body>
</html>
